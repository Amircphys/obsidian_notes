### Строки в Питоне

   Чтобы строка стала «сырой», перед ней необходимо поставить символ `r` в любом регистре. В такой строке отключается экранирование. Это значит, что обратный слеш считается самостоятельным символом. Ещё один префикс -  `f`. Он позволяет форматировать строку, вставляя в неё какие-либо выражения. Можно использовать несколько префиксов сразу.
   # Используем 2 префикса одновременно: 
```
   raw_f_string = rf'C:\file.txt' 
   f_raw_string = fr'C:\file.txt'
```
Так как в выражениях внутри f-строк запрещено использовать обратный слеш `\` (это ограничение f-строк, при нарушении которого появляется ошибка: `SyntaxError: f-string expression part cannot include a backslash`), то разницы между fr-строками и rf-строками нет. Единственное их различие - порядок применения префиксов к строке, но, как мы уже поняли, он ни на что не влияет.

### Экранирование и регулярные выражения
В строках Python по умолчанию работает экранирование. Всё это из-за того, что в Python существуют специальные (их ещё называют экранируемые или управляющие) последовательности, которые заменяются на другие символы. Например, последовательность символов `\n` в примере выше стала символом перехода на новую строку.

Чтобы сказать интерпретатору, что экранировать последовательность не нужно, достаточно поставить перед ней обратный слеш. В регулярных выражениях тоже есть экранирование. Каждое регулярное выражение, которое используется в коде, компилируется интерпретатором, и заменяет управляющие последовательности на другие символы. **Если нам нужно использовать какой-то спецсимвол как простой текст, то достаточно поставить перед ним `\`, как и в обычных строках Python.** Это работает со всеми спецсимволами! Если вы используете обычную строку в регулярном выражении, то сначала срабатывает экранирование строки в Python, а потом срабатывает второе экранирование при компиляции регулярного выражения.
Именно в этом случае нас спасут **сырые строки**. С помощью них мы отключим экранирование в строках Python и будем работать только с одним экранированием - экранированием в регулярных выражениях.

#### Использование квадратных скобок
```
r'[cr1]' # Найдёт c, r, и 1 
r'[cr]at' # Найдёт слова cat и rat 
r'[12]7[56]' # Найдёт 175, 176, 275, 276

r'[^12]' # Найдёт всё, кроме 1 и 2 
r'[^12]7' # Найдёт все последовательности, что заканчиваются на 7, и не начинаются на 1 и 2
```
Если символ `^` не стоит в начале скобок или он экранирован - он воспринимается как обычный текст:
```
r'[0^]_[0^]' # Найдёт 0_0, 0_^, ^_0, ^_^ 
r'[\^0]_[\^0]' # Найдёт 0_0, 0_^, ^_0, ^_^
```
Диапазоны и сокращения:
```
r'[0-9]' # То же самое, что и [0123456789] 
r'[a-z]' # То же самое, что и [abcdefghijklmnopqrstuvwxyz] 
r'[A-Z]' # То же самое, что и [ABCDEFGHIJKLMNOPQRSTUVWXYZ] 
r'[а-я]' # То же самое, что и [абвгдежзийклмнопрстуфхцчшщъыьэюя] 
r'[А-Я]' # То же самое, что и [АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ]

# Можно получать неполный алфавит или не все цифры:
r'[4-7]' # То же самое, что и [4567] 
r'[x-z]' # То же самое, что и [xyz] 
r'[B-D]' # То же самое, что и [BCD] 
r'[а-ж]' # То же самое, что и [абвгдеж] 
r'[П-Т]' # То же самое, что и [ПРСТ] 
r'[6-D]' # То же самое, что и [6789:;<=>?@ABCD]

А также совмещать синтаксис:

r'[4-7qwerty]' # То же самое, что и [qwerty4567] 
r'[23x-z1]' # То же самое, что и [xyz123] 
r'[B-DF]' # То же самое, что и [BCDF]
```
Распространённая ошибка: регулярное выражение `[21-47]` не найдёт числа от 21 до 47, оно будет равносильно выражению `[212347]`,

Чтобы использовать `-` как обычный символ - его достаточно экранировать или поставить в конец или начало скобок:
```
r'[4\-7]' # Найдёт 4, -, и 7 
r'[-xz]' # Найдёт -, x, и z 
r'[^-xz]' # Найдёт всё, кроме -, x, и z 
r'[BD-]' # Найдёт B, D, и -
```


| Шаблон | Соответствие                                                                                                                                         |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------------------- |
| `\n`   | Новая строка                                                                                                                                         |
| `.`    | Любой символ, кроме символа новой строки. Если `flags=re.DOTALL` - любой символ.                                                                     |
| `\s`   | Любой символ пробела, табуляции или новой строки.                                                                                                    |
| `\S`   | Любой символ, кроме пробела, табуляции или новой строки.                                                                                             |
| `\d`   | Любая цифра. Ищет все цифры: арабские, персидские, индийские, и так далее. Не эквивалентен `[0-9]`                                                   |
| `\D`   | Любой символ, кроме цифр.                                                                                                                            |
| `\w`   | Любая буква, цифра, или `_`. Шаблон не соответствует выражению `[a-zA-Z0-9_]`! Буквы используются не только латинские, туда входит множество языков. |
| `\W`   | Любой символ, кроме букв, цифр, и `_`.                                                                                                               |
| `\b`   | Промежуток между символом, совпадающим с \w,<br>и символом, не совпадающим с \w в любом порядке.                                                     |
| `\B`   | Промежуток между двумя символами,<br>совпадающими с \w или \W.                                                                                       |
| `\A`   | Начало всего текста                                                                                                                                  |
| `\Z`   | Конец всего текста                                                                                                                                   |
| `^`    | Начало всего текста или начало строчки текста, если `flags=re.MULTILINE`                                                                             |
| `$`    | Конец всего текста или конец строчки текста, если `flags=re.MULTILINE`                                                                               |
```
r'[A$Z]' # Ищет символы A,$,Z 
r'^text$' # Ищет text между началом и концом строки 
r'100\$' # Ищет 100$
```
```
r'[A.Z]' # Ищет символы A,.,Z 
r'text.' # Ищет text с любым символом, кроме перехода на новую строку r'1\.000\$' # Ищет 1.000$
```
```
r'Как-то так' # Ищет Как-то так 
r'[+-]' # Ищет символы +,- 
r'[^-+]' # Ищет любой символ, кроме +, - 
r'[a-z]' # Ищет все буквы латинского алфавита в нижнем регистре 
r'[a\-z]' # Ищет символы a,-,z
r`^$` # найдет пустую строку
```
|                   |                                                      |
| ----------------- | ---------------------------------------------------- |
| **Квантификатор** | **Использование**                                    |
| `{n}`             | Ровно n повторений                                   |
| `{m,n}`           | От m до n повторений.                                |
| `{m,}`            | Не менее m повторений                                |
| `{,n}`            | Не более n повторений                                |
| `?`               | Ноль или одно повторение<br><br>То же, что и `{0,1}` |
| `*`               | Ноль или более повторений<br><br>То же, что и `{0,}` |
| `+`               | Одно или более повторений<br><br>То же, что и `{1,}` |
- В каждом квантификаторе учитываются и начало, и конец отрезка.
- Каждый квантификатор по умолчанию - жадный. Жадные квантификаторы пытаются захватить как можно больше символов.

```
Ленивые квантификаторы 
{m,n}? - от m до n 
{,n}? - до n 
{m,}? - от m 
*? - от 0 
+? - от 1 
?? - от 0 до 1 
Каждый из этих квантификаторов будет пытаться захватить как можно меньше символов.
```

# Группирующие скобки

| Синтаксис                  | Использование                                                                                                  |
| -------------------------- | -------------------------------------------------------------------------------------------------------------- |
| `(regex)`                  | Обыкновенная скобочная группа. Захватывает символы, о которых можно будет получить более подробную информацию. |
| `(?P<name>regex)`          | Обычная скобочная группа, но вместе с номером ей будет присвоено имя `name`.                                   |
| `(?P<name>regex)(?P=name)` | Скобочная группа с именем позволяет к ней обращаться и искать такой же текст, который она захватила.           |
```
r'(\d{3})\1' - все повторяющиеся последовательности из трёх цифр, которые идут друг за другом;
r'\b(?P<name>[а-яё]+)-?(?P=name)\b' -  все слова и словосочетания, состоящие из двух одинаковых частей
r'([a-zA-Zа-яёА-ЯЁ])\1' - найдёт все повторяющиеся буквы в тексте.
r'(\d{2})\1' -  все повторяющиеся последовательности из двух цифр
```

```
regex = r"^(\[)?\d(?(1)\]|)$" # Выражение для поиска цифры в скобках или без скобок # Группа (\[)? ищет первую скобку. К группе применён квантификатор ?, т.к. скобки может и не быть # Условие (?(1)\]|) ищет правую скобку, если в первой группе найдена левая скобка. # Если первая группа ничего не нашла, то условие ничего не ищет. # Найдёт 1 и [2] # Проигнорирует 3] и [4
```
В регулярных выражениях существуют условия. Если у группы `n` нашлись совпадения - возвращается шаблон до `|`. В противном случае возвращается шаблон после `|`. Шаблон после `|` необязателен и может быть опущен.

## Non-capturing group
`(?:)` - скобочное выражение, которое группирует регулярное выражение, но не захватывает в его отдельную группу. Так и называется - `Non-capturing group`, т.е. группа без захвата.

Его можно использовать, например, чтобы применять квантификаторы сразу к нескольким символам:
![[Pasted image 20250221185218.png]]
Это делает Non-capturing group удобным инструментом для определения областей применения квантификаторов и других операций в регулярных выражениях без создания дополнительных захватываемых групп.

## В чём же разница между группой и Non-capturing group?

Мы прошли 2 похожих темы: Group и Non-capturing group. Скорее всего, вам может показаться, что от Non-capturing group нет смысла, т.к. обычная группа полностью её заменяет, так ещё и у неё больше возможностей для применения.

На самом деле, если рассматривать этот вопрос с точки зрения синтаксиса регулярных выражений, всё так и есть. Но в Python работа функций из модуля re очень сильно зависит от групп, и чтобы ваша программа не вела себя непредсказуемо (т.к. мы ещё не знаем как работают группы в Python), то вместо групп следует использовать Non-capturing group.

Даже после изучения работы с группами в Python **группы имеет смысл использовать только тогда, когда вы к ним обращаетесь или работаете с их данными**. Во всех остальных случаях нужно использовать Non-capturing group.



# Lookahead и Lookbehind

Очень полезные скобочные группы, которые позволяют "смотреть" что находится сзади и спереди регулярных выражений. Часто используются, когда нужно найти текст или какую-то последовательность между символами, которые не нужно захватывать в регулярное выражение.

| Название            | Синтаксис | Использование                                                                                | Пример     | Применяем к тексту         |
| ------------------- | --------- | -------------------------------------------------------------------------------------------- | ---------- | -------------------------- |
| Positive Lookahead  | `(?=)`    | Проверяет стоит ли переданное выражение после шаблона. Не захватывает никаких символов.      | `2(?= 3)`  | 1 **2** 3<br><br>   6 2 8` |
| Negative Lookahead  | `(?!)`    | Проверяет что переданное выражение не стоит после шаблона. Не захватывает никаких символов.  | `2(?! 3)`  | 1 2 3<br><br>   6 **2** 8  |
| Positive Lookbehind | `(?<=)`   | Проверяет стоит ли переданное выражение перед шаблоном. Не захватывает никаких символов.     | `(?<=6 )2` | 1 2 3`<br><br>  6 **2** 8  |
| Negative Lookbehind | `(?<!)`   | Проверяет что переданное выражение не стоит перед шаблоном. Не захватывает никаких символов. | `(?<!6 )2` | 1 **2** 3<br><br>`6 2 8`   |

Давайте разберём их работу на наглядном примере. Допустим, нам нужно найти слово `test`, окружённое среди двух цифр, но сами цифры захватывать не нужно. Тогда мы можем использовать скобочные выражения.


# Ограничение Lookbehind

Обратите внимание, что все выражения в lookbehind должны быть фиксированной ширины, иначе вы получите ошибку `re.error: look-behind requires fixed-width pattern`.

Движок регулярных выражений в Python не может работать с выражениями неопределённой длины в Lookbehind из-за технических особенностей. 

```python
# Вызовут ошибку:

r'(?<=test{0,})regex'
r'(?<=g?)regex'
r'(?<!Python+)regex'

# Длина вхождений выражений в Lookbehind может быть разной
# Поэтому появится ошибка



# Ошибки не будет:

r'(?<=test)regex'
r'(?<=g{21})regex'
r'(?<!Pytho[mn])regex'

# Длина вхождений выражений в Lookbehind фиксированная
# Всё выполнится без ошибок
```

Такая особенность есть только у Lookbehind. Lookahead позволяет использовать внутри себя выражения неопределённой длины.

```
r'(?<=\[\^START\]).*(?={\(END\.\)})' -  последовательность из любых символов от `[^START]` до `{(END.)}`
```

#### Опреация 'или'
Синтаксис регулярных выражений позволяет писать такие выражения, которые найдут нужные строки при соответствии их хотя бы одному из выражений. Например, выражение: `r'Привет|Пока'` - найдёт все слова `Привет` и `Пока` в тексте.
Если использовать оператор или в скобочных выражениях или группах, то он *не* затронет символы извне. Обратите внимание, что в lookbehind можно использовать `|`, только если все шаблоны одинаковой длины. То есть такие выражения будут правильными: 
```
(?<=hi!|bye)
(?<![abcdef]|\d)
(?<=\w|\W|\s)
```
Такое использование lookbehind вызовет ошибку `re.error: look-behind requires fixed-width pattern`:
```
(?<=hi!|long_text)
(?<![abcdef]|\d{4})
(?<=\w\s|\W)
```
Для того, чтобы обойти такое исключение, нужно использовать `|` в `non-capturing group`:
```
(?:(?<=hi!)|(?<=long_text))
(?:(?<![abcdef])|(?<!\d{4}))
(?:(?<=\w\s)|(?<=\W))
```
###### Оператор "Или" в квадратных скобках

Очень часто вижу эту ошибку у учеников, начинающих изучать регулярные выражения. Если вы поставите символ `|` в квадратные скобки, то ваш шаблон будет просто искать этот символ. Он не будет работать как оператор "Или".

```
# Задача: Нужно найти слово Hi или Bye 

wrong_regex = r'[Hi|Bye]' 
# Неправильное регулярное выражение, т.к. оно равносильно следующему выражению [BHeiy|] 
# Квадратные скобки используются только для замены символов, условие или в них не работает 

correct_regex = r'(Hi|Bye)' 
# Поставленную выше задачу решает 

correct_regex2 = r'(?:Hi|Bye)' 
# Non-capturing group идеально подходит для группировки шаблонов 

correct_regex3 = r'Hi|Bye' 
# Шаблон без групппировки. Также работает, поставленную выше задачу решает
```


*Задача:* Напишите регулярное выражение, которое найдёт следующие последовательности в тексте: [я готов, я готова, ты готов, ты готова, он готов, она готова, мы готовы, вы готовы, они готовы]
 Решение:  `regex = r'((мы|вы|они)|(я|ты)|(она)|(он)) готов(?(2)ы|(?(3)а?|(?(4)а|)))\b'`
 (Группы идут со второй, т. к. первая группа это внешние скобки, которые включают в себя все имеющиеся группы.)
*Задача*: Найдите трёхзначные номера, перед которыми идёт `№`, `Номер`, или `Number`.  Решение:  `regex = r'(?:(?<=№ )|(?<=Номер )|(?<=Number ))\d{3}'`

# Python re module


#### Match
```
re.match(pattern, string, flags=0) – то же самое, что и re.search(), но ищет совпадение в начале строки.

### Параметры:

- pattern - регулярное выражение
- string - строка, к которой нужно применить регулярное выражение
- flags - флаги, пройдём позже

### Возвращаемое значение:

- Объект Match, если совпадение было найдено
- None, если нету совпадений

Объект Match: 
1. group([_group1_, _..._]) - Возвращает найденное совпадение по номеру группы. Если в метод не передать аргумент, то он по умолчанию выведет нулевую группу. Пример: print(match.group())

2. start(__group=0), end(__group=0) - возвращают индексы начала и конца совпадения с регулярным выражением группы, номер которой был передан в метод.
Пример: print(match.start(0), match.end(0))

3. span(__group=0) - возвращает кортеж с индексом начала и конца совпадения группы, номер которой был передан в метод. Он работает аналогично методам `start`, `end`, но возвращает пару чисел.
Пример: print(match.span(0)

4. pos (endpos) - это позиция, с которой функция начинает искать совпадения (до которой функция ищет совпадения).
Пример: print(match.pos, match.endpos)

5. re -  регулярное выражение, которое использовалось для поиска
Пример: print(match.re)

6. string - можно получить строку, в которой искались совпадения
Пример: print(match.string)
```

#### Search
`re.search(pattern, string, flags=0)` -  ищет первое совпадение в строке
###### Параметры:

- `pattern` - регулярное выражение
- `string` - строка, к которой нужно применить регулярное выражение
- `flags` - флаги, пройдём позже
###### Возвращаемое значение:

- Объект `Match`, если совпадение было найдено
- `None`, если нету совпадений

#### fullmatch
**`re.fullmatch(pattern, string, flags=0)`** - определяет соответствие строки переданному шаблону. Если вся строка соответствует шаблону - выводит объект `Match`, иначе - `None`.
##### Параметры:
- `pattern` - регулярное выражение
- `string` - строка, к которой нужно применить регулярное выражение
- `flags` - флаги, пройдём позже
##### Возвращаемое значение:

- Объект `Match`, если вся строка соответствует шаблону
- `None`, если строка не соответствует шаблону