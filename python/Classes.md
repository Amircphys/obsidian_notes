
### Применение геттер и сеттер методов для закрытых атрибутов классов
Как и во всех иных языках, в ООП на Python используется принцип называемый **инкапсуляцией**. Под этим термином, в частности, подразумевается ограничение доступа к некоторым составляющим объект компонентам (методам и атрибутам) так, чтобы они были доступны только через, определенные, создающиеся внутри их классов, специальные методы – **геттеры** и **сеттеры**.
- **Геттеры** представляют собой методы, используемые в ООП для получения доступа к закрытым атрибутам (свойствам) интересующего нас класса.
- **Сеттеры** являются методами, применяемыми в ООП с целью присвоения (изменения) значения у закрытых атрибутов (свойств) интересующего нас класса.

Одиночное подчеркивание в начале имени атрибута всегда свидетельствует о том, что свойство или метод является приватным и, не может быть использован вне методов своего класса. Однако, этот атрибут вне класса всегда будет доступен по своему имени с одиночным подчеркиванием:
```
class PrimerA:
    def _private(self):
        print("Данный метод является 100% приватным!")

a = PrimerA()
a._private() # Данный метод является 100% приватным!
```
Двойное же подчеркивание в начале имени атрибута делает его абсолютно закрытым от доступа по имени вне того класса, в котором этот атрибут был создан:
```
class PrimerB:
    def __private(self):
        print("Данный метод закрыт от доступа вне своего класса!")
b = PrimerB()
b.__private()
Traceback (most recent call last):
  File "<stdin>", line 6, in <module>
AttributeError: 'PrimerB' object has no attribute '__private'.
```
Хотя атрибут с двойным начальным подчеркиванием и не имеет доступа по своему имени вне создавшего его класса, однако до него можно все же “достучаться” через имя его класса. Так, для доступа к нашему экземпляру **b** для этого нужно просто вместо выражения **_b.__private()_** применить выражение **_b._PrimerB__private()_**. Вместе с тем, данный обходной путь доступа к закрытым атрибутам классов в отличии от применения _геттеров_ и _сеттеров_ не только крайне громоздок, но и не пригоден для обеспечения гибкой _инкапсуляции_.

Вполне очевидно, что **закрытые атрибуты** по аналогии со все тем же инстинктом самосохранения для живых существ, должны предотвращать некорректное изменение тех свойств, которые в соответствующих классах могут иметь только строго определенные значения. Следовательно, все попытки изменить или прочитать вышеназванные свойства в теории должны предварительно проверяться на корректность, предусматриваемых в этих попытках действий. Такие проверки как раз и осуществляют _геттеры_ и _сеттеры_, выступающие своеобразными стражами, предохраняющими классы и их экземпляры от некорректных изменений.

Для геттер методов используется декоратор **@property**, а для сеттер методов – декоратор **@method_name.setter**, где вместо **method_name** должно быть подставлено имя конкретного метода, используемого в качестве сеттера. Для применения этих декораторов в классах, они просто должны быть размещены сразу же перед определением соответствующих геттер или сеттер методов.

В итоге, благодаря использованию вышеназванных декораторов мы сможем получать доступ к закрытым атрибутам класса точно также, как мы это делали в отношении обычных (общедоступных) атрибутов.

```
class Decorators:

def __init__(self, var):
	# Инициализация закрытого атрибута класса
	self.a = var
	
	# Имя закрытого атрибута класса и имена соответствующих
	# геттер и сеттер методов должны быть одинаковыми
	@property
	def a(self):
		return self.__a

	@a.setter
	def a(self, var):
		if var > 0 and var % 2 == 0:
			self.__a = var
		else:
			self.__a = 2

# Создание экземпляра для класса 'Decorators'
ekz = Decorators(23)
print(ekz.a) # 2
```

```
class Author:
	def __init__(self, name):
		self.name = name
	
	@property
	def name(self):
		"""name doc"""
		return self.__name
	
	@name.setter
	def name(self, val):
		self.__name = val
	
	@name.deleter
	def name(self, val):
		self.__name = val
```



#### From LLM

В Python нет строгой инкапсуляции, как в других языках, но есть соглашения. Protected атрибуты обозначаются одним подчеркиванием (_var), а private — двумя (__var). Но это просто соглашение, и доступ к ним все равно можно получить.

сеттер — это метод, который устанавливает значение атрибута, возможно, с проверками. Но в Python чаще используют свойства (@property) для управления доступом к атрибутам. Нужно объяснить, как работает @property, @x.setter и @x.deleter.

```
class MyClass:
    def __init__(self):
        self._x = 0  # Protected атрибут

    @property
    def x(self):
        print("Получение значения")
        return self._x

    @x.setter
    def x(self, value):
        if value < 0:
            raise ValueError("Значение не может быть отрицательным")
        print("Установка значения")
        self._x = value
```

```
class MyClass:
    def __init__(self):
        self.__x = 0  # Private атрибут (реальное имя: _MyClass__x)

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, value):
        if not isinstance(value, int):
            raise TypeError("Только целые числа")
        self.__x = value

obj = MyClass()
obj.x = 42  # Работает через сеттер
print(obj.x)  # 42

# Прямой доступ к private атрибуту (не рекомендуется!):
print(obj._MyClass__x)  # 42
```

**Доступ к атрибутам**:
Чтобы найти атрибут объекта obj, python обыскивает:
	1.  Сам объект (obj.__dict__ и его системные атрибуты)
	2.  Класс объекта (obj.__class__.__dict__).
	3.  Классы, от которых унаследован класс объекта (obj.__class__.__mro__)

**Магические атрибуты**
 `__name__` — имя класса
`__module__` — модуль, в котором объявлен класс
`__qualname__` — fully qualified имя
`__doc__` — докстринг
`__annotations__` — аннотации статических полей класса
`__dict__` — namespace класса
`__bases__` — базовые классы
`__base__` — базовый класс, который указан первым по порядку
`__mro__` — список классов, упорядоченный по вызову функции super
`__self__` — объект класса
`__func__` — сама функция, которую мы в классе объявили
`__repr__` — представление объекта. Если возможно, должно быть валидное python
выражение для создание такого же объекта
`__str__` — вызывается функциями str, format, print
`__format__` — вызывается при форматировании строки
`__slots__` - Позволяет явно указать поля, которые будут в классе. В случае указания __slots__ пропадают поля __dict__ и __weakref__. Используя __slots__ можно экономить на памяти и времени доступа к атрибутам объекта.