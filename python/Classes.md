
### Применение геттер и сеттер методов для закрытых атрибутов классов
Как и во всех иных языках, в ООП на Python используется принцип называемый **инкапсуляцией**. Под этим термином, в частности, подразумевается ограничение доступа к некоторым составляющим объект компонентам (методам и атрибутам) так, чтобы они были доступны только через, определенные, создающиеся внутри их классов, специальные методы – **геттеры** и **сеттеры**.
- **Геттеры** представляют собой методы, используемые в ООП для получения доступа к закрытым атрибутам (свойствам) интересующего нас класса.
- **Сеттеры** являются методами, применяемыми в ООП с целью присвоения (изменения) значения у закрытых атрибутов (свойств) интересующего нас класса.

Одиночное подчеркивание в начале имени атрибута всегда свидетельствует о том, что свойство или метод является приватным и, не может быть использован вне методов своего класса. Однако, этот атрибут вне класса всегда будет доступен по своему имени с одиночным подчеркиванием:
```
class PrimerA:
    def _private(self):
        print("Данный метод является 100% приватным!")

a = PrimerA()
a._private() # Данный метод является 100% приватным!
```
Двойное же подчеркивание в начале имени атрибута делает его абсолютно закрытым от доступа по имени вне того класса, в котором этот атрибут был создан:
```
class PrimerB:
    def __private(self):
        print("Данный метод закрыт от доступа вне своего класса!")
b = PrimerB()
b.__private()
Traceback (most recent call last):
  File "<stdin>", line 6, in <module>
AttributeError: 'PrimerB' object has no attribute '__private'.
```
Хотя атрибут с двойным начальным подчеркиванием и не имеет доступа по своему имени вне создавшего его класса, однако до него можно все же “достучаться” через имя его класса. Так, для доступа к нашему экземпляру **b** для этого нужно просто вместо выражения **_b.__private()_** применить выражение **_b._PrimerB__private()_**. Вместе с тем, данный обходной путь доступа к закрытым атрибутам классов в отличии от применения _геттеров_ и _сеттеров_ не только крайне громоздок, но и не пригоден для обеспечения гибкой _инкапсуляции_.

Вполне очевидно, что **закрытые атрибуты** по аналогии со все тем же инстинктом самосохранения для живых существ, должны предотвращать некорректное изменение тех свойств, которые в соответствующих классах могут иметь только строго определенные значения. Следовательно, все попытки изменить или прочитать вышеназванные свойства в теории должны предварительно проверяться на корректность, предусматриваемых в этих попытках действий. Такие проверки как раз и осуществляют _геттеры_ и _сеттеры_, выступающие своеобразными стражами, предохраняющими классы и их экземпляры от некорректных изменений.

Для геттер методов используется декоратор **@property**, а для сеттер методов – декоратор **@method_name.setter**, где вместо **method_name** должно быть подставлено имя конкретного метода, используемого в качестве сеттера. Для применения этих декораторов в классах, они просто должны быть размещены сразу же перед определением соответствующих геттер или сеттер методов.

В итоге, благодаря использованию вышеназванных декораторов мы сможем получать доступ к закрытым атрибутам класса точно также, как мы это делали в отношении обычных (общедоступных) атрибутов.

```
class Decorators:

def __init__(self, var):
	# Инициализация закрытого атрибута класса
	self.a = var
	
	# Имя закрытого атрибута класса и имена соответствующих
	# геттер и сеттер методов должны быть одинаковыми
	@property
	def a(self):
		return self.__a

	@a.setter
	def a(self, var):
		if var > 0 and var % 2 == 0:
			self.__a = var
		else:
			self.__a = 2

# Создание экземпляра для класса 'Decorators'
ekz = Decorators(23)
print(ekz.a) # 2
```

```
class Author:
	def __init__(self, name):
		self.name = name
	
	@property
	def name(self):
		"""name doc"""
		return self.__name
	
	@name.setter
	def name(self, val):
		self.__name = val
	
	@name.deleter
	def name(self, val):
		self.__name = val
```



#### From LLM

В Python нет строгой инкапсуляции, как в других языках, но есть соглашения. Protected атрибуты обозначаются одним подчеркиванием (_var), а private — двумя (__var). Но это просто соглашение, и доступ к ним все равно можно получить.

сеттер — это метод, который устанавливает значение атрибута, возможно, с проверками. Но в Python чаще используют свойства (@property) для управления доступом к атрибутам. Нужно объяснить, как работает @property, @x.setter и @x.deleter.

```
class MyClass:
    def __init__(self):
        self._x = 0  # Protected атрибут

    @property
    def x(self):
        print("Получение значения")
        return self._x

    @x.setter
    def x(self, value):
        if value < 0:
            raise ValueError("Значение не может быть отрицательным")
        print("Установка значения")
        self._x = value
```

```
class MyClass:
    def __init__(self):
        self.__x = 0  # Private атрибут (реальное имя: _MyClass__x)

    @property
    def x(self):
        return self.__x

    @x.setter
    def x(self, value):
        if not isinstance(value, int):
            raise TypeError("Только целые числа")
        self.__x = value

obj = MyClass()
obj.x = 42  # Работает через сеттер
print(obj.x)  # 42

# Прямой доступ к private атрибуту (не рекомендуется!):
print(obj._MyClass__x)  # 42
```

**Доступ к атрибутам**:
Чтобы найти атрибут объекта obj, python обыскивает:
	1.  Сам объект (obj.__dict__ и его системные атрибуты)
	2.  Класс объекта (obj.__class__.__dict__).
	3.  Классы, от которых унаследован класс объекта (obj.__class__.__mro__)

**Магические атрибуты**
 `__name__` — имя класса
`__module__` — модуль, в котором объявлен класс
`__qualname__` — fully qualified имя
`__doc__` — докстринг
`__annotations__` — аннотации статических полей класса
`__dict__` — namespace класса
`__bases__` — базовые классы
`__base__` — базовый класс, который указан первым по порядку
`__mro__` — список классов, упорядоченный по вызову функции super
`__self__` — объект класса
`__func__` — сама функция, которую мы в классе объявили
`__repr__` — представление объекта. Если возможно, должно быть валидное python
выражение для создание такого же объекта
`__str__` — вызывается функциями str, format, print
`__format__` — вызывается при форматировании строки
`__slots__` - Позволяет явно указать поля, которые будут в классе. В случае указания __slots__ пропадают поля __dict__ и __weakref__. Используя __slots__ можно экономить на памяти и времени доступа к атрибутам объекта.

В Python существуют два типа методов, которые работают с классами, а не с экземплярами: **`@staticmethod`** и **`@classmethod`**. Разберем их различия.

---

### 1. **`@classmethod`**
- **Первый аргумент**: Принимает ссылку на сам класс (по соглашению называется `cls`).  
- **Назначение**: Используется для работы с классом, а не с экземпляром. Может изменять состояние класса или создавать его экземпляры.  
- **Примеры использования**: 
  - Фабричные методы для создания объектов.
  - Альтернативные конструкторы (например, из строки, JSON и т.д.).
  - Методы, которые работают с классом как с сущностью (например, изменение атрибута класса).

**Пример:**
```python
class MyClass:
    class_attr = "Классовый атрибут"

    @classmethod
    def factory_method(cls, data):
        # cls ссылается на класс, из которого вызван метод
        return cls(data)  # Создает экземпляр этого класса

    @classmethod
    def print_class_attr(cls):
        print(cls.class_attr)
```

---

### 2. **`@staticmethod`**
- **Первый аргумент**: Не принимает ни `self`, ни `cls`. Работает как обычная функция, но принадлежит пространству имен класса.  
- **Назначение**: Используется для утилитарных функций, логически связанных с классом, но не требующих доступа к классу или экземпляру.  
- **Примеры использования**: 
  - Вспомогательные вычисления.
  - Проверки данных, парсинг, форматирование.

**Пример:**
```python
class MathUtils:
    @staticmethod
    def add(a, b):
        return a + b

    @staticmethod
    def is_even(number):
        return number % 2 == 0
```

---

### **Различия**
| **Критерий**         | **`@classmethod`**                      | **`@staticmethod`**               |
|-----------------------|-----------------------------------------|------------------------------------|
| **Первый аргумент**   | `cls` (ссылка на класс)                 | Нет неявных аргументов            |
| **Доступ к классу**   | Может читать/изменять атрибуты класса   | Не имеет доступа к классу         |
| **Наследование**      | Видит подклассы (через `cls`)          | Не зависит от иерархии классов    |
| **Использование**     | Фабричные методы, альтернативные конструкторы | Утилитарные функции, не зависящие от состояния |

---

### **Когда что использовать?**
- **`@classmethod`**: Когда метод должен взаимодействовать с классом или создавать его экземпляры.
- **`@staticmethod`**: Когда метод выполняет задачу, связанную с классом, но не требует доступа к его данным.

**Пример с наследованием:**
```python
class Parent:
    @classmethod
    def create(cls):
        print(f"Создан объект класса {cls.__name__}")

class Child(Parent):
    pass

Parent.create()  # Создан объект класса Parent
Child.create()   # Создан объект класса Child (класс передан через cls)
```

Здесь `@classmethod` позволяет методу `create()` работать с подклассами, что полезно для полиморфизма.


### Классы: доступ к атрибутам

Чтобы найти атрибут объекта obj, python обыскивает:
1. Сам объект (obj.__dict__ и его системные атрибуты)
2. Класс объекта (obj.__class__.__dict__).
3. Классы, от которых унаследован класс объекта (obj.__class__.__mro__)

 Магические методы (dunder methods) в Python — это специальные методы, которые начинаются и заканчиваются двойным подчеркиванием. Они позволяют кастомизировать поведение классов и объектов. Разберем основные из них на примерах:

---

### 1. **`__new__`**
**Зачем:** Создает экземпляр класса (вызывается **до** `__init__`).  
**Пример:** Ограничение создания объекта:
```python
class Singleton:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

a = Singleton()
b = Singleton()
print(a is b)  # True (это один и тот же объект)
```

---

### 2. **`__del__`**
**Зачем:** Вызывается при удалении объекта (но не гарантированно!).  
**Пример:** Закрытие ресурсов:
```python
class FileHandler:
    def __init__(self, filename):
        self.file = open(filename, 'r')

    def __del__(self):
        self.file.close()
        print("Файл закрыт!")
```

⚠️ Не стоит полагаться на `__del__` для критически важных операций — используйте `with` или явный вызов методов.

---

### 3. **`__set_name__`**
**Зачем:** Позволяет дескриптору (например, свойству) узнать имя атрибута в классе.  
**Пример:**
```python
class Validator:
    def __set_name__(self, owner, name):
        self.name = name

    def __get__(self, instance, owner):
        return instance.__dict__[self.name]

class User:
    name = Validator()  # __set_name__ узнает, что атрибут называется "name"
```

---

### 4. **`__call__`**
**Зачем:** Позволяет вызывать объект как функцию.  
**Пример:**
```python
class Adder:
    def __call__(self, a, b):
        return a + b

add = Adder()
print(add(2, 3))  # 5
```

---

### 5. **`__slots__`**
**Зачем:** Ограничивает атрибуты экземпляра для экономии памяти.  
**Пример:**
```python
class Point:
    __slots__ = ('x', 'y')  # Разрешенные атрибуты

    def __init__(self, x, y):
        self.x = x
        self.y = y

p = Point(1, 2)
p.z = 3  # Ошибка: нельзя добавить новый атрибут!
```

⚠️ Нельзя использовать `__slots__` с наследованием, если родитель не имеет `__slots__`.

---

### 6. **`__getattribute__`**
**Зачем:** Вызывается при **любом** обращении к атрибуту.  
**Пример:** Логирование доступа:
```python
class Spy:
    def __getattribute__(self, name):
        print(f"Доступ к атрибуту: {name}")
        return super().__getattribute__(name)

obj = Spy()
obj.x = 10
print(obj.x)  # "Доступ к атрибуту: x" → 10
```

⚠️ **Важно:** Всегда используйте `super().__getattribute__()`, иначе будет рекурсия!

---

### 7. **`__getattr__`**
**Зачем:** Вызывается, если атрибут **не найден**.  
**Пример:** Динамическое создание атрибутов:
```python
class MagicBag:
    def __getattr__(self, name):
        return f"Атрибут {name} не найден, но мы его придумали!"

bag = MagicBag()
print(bag.color)  # "Атрибут color не найден, но мы его придумали!"
```

---

### 8. **`__setattr__`**
**Зачем:** Вызывается при **установке** атрибута.  
**Пример:** Запрет изменения атрибута:
```python
class Immutable:
    def __init__(self, value):
        super().__setattr__('value', value)  # Обход __setattr__

    def __setattr__(self, name, value):
        raise AttributeError("Нельзя менять атрибуты!")

obj = Immutable(10)
obj.value = 20  # Ошибка!
```

---

### 9. **`__delattr__`**
**Зачем:** Вызывается при **удалении** атрибута.  
**Пример:** Запрет удаления атрибута:
```python
class Protected:
    def __delattr__(self, name):
        if name == "secret":
            raise AttributeError("Нельзя удалять секреты!")
        super().__delattr__(name)

obj = Protected()
obj.secret = 123
del obj.secret  # Ошибка!
```

---

### 10. **`__dir__`**
**Зачем:** Возвращает список доступных атрибутов.  
**Пример:** Кастомизация вывода `dir(obj)`:
```python
class Simple:
    def __dir__(self):
        return ['a', 'b', 'c']

obj = Simple()
print(dir(obj))  # ['a', 'b', 'c']
```

---

### **Итог:**
- **`__new__`**, **`__init__`**, **`__del__`** — управление жизненным циклом объекта.  
- **`__set_name__`** — для дескрипторов.  
- **`__call__`** — объект как функция.  
- **`__slots__`** — оптимизация памяти.  
- **`__getattr__`**, **`__getattribute__`**, **`__setattr__`**, **`__delattr__`** — управление доступом к атрибутам.  
- **`__dir__`** — кастомизация списка атрибутов.  
