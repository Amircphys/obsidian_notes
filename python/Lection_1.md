## Базовые типы: числа
###### Целые числа (int)
```
num = 42
num = 42_000_000
num = 0o10 # 8
num = 0x10 # 16
```
###### Вещественные числа (float):
```
num = 3.14
```
######  Комплексные числа (complex):
```
num = 9 + 0.75j # num.real, num.imag
```
###### Арифметические операции
```
Сложение: +
Вычитание: -
Умножение: *
Деление: /
Целочисленное деление: //
Остаток от деления: %
Возведение в степень: **
```
###### Битовые операции
```
1. Побитовый вывод:  bin(5) =  '0b101'

2. Умножение: & - при сравнении двух бит (в одном и том же разряде) `&` выдает 1 (то есть бит будет скопирован), если бит есть в обоих сравниваемых операндах, и 0, если это условие не выполняется (то есть бит отсутствует хотя бы в одном из операндов). 3 & 6 = 2 (0b011 & 0b110 = 0b010)

3. Сложение |: 3 | 6 = 7 (0b011 | 0b110 = 0b111)

4. Инверсия: ~ не сравнивает значения, а переворачивает биты в целочисленных значениях. ~30 = -31, ~0=-1, ~-40 = 39

5. Исключающее ИЛИ: ^ - при сравнении двух бит `**^**` выдает 1 (бит будет скопирован), если сравниваемые операнды различаются, и 0, если они одинаковы.
5 ^ 2 = 7 (0b0101 ^ 0b0010 = 0b0111)

6. Побитовый сдвиг: <<, >>. Примеры: 1 << 1 = 2 (0b01 << 1 = 0b10), 1 << 2 = 4 (0b001 << 2 == 0b100), 8 >> 3 = 1 (0b1000 >> 3 = 0b0001)
```
Когда мы присваиваем значение переменной, в памяти создается объект и пременная ссылается на этот объект. Если мы изменим значение данной переменной (например, x += 1), в памяти создается новый объект и переменная ссылается уже на новое значение, так что id уже будет другой. 

Питон кэширует целые числа от -5 до 256, т.е. все пременные имеющие значения в данном диапазоне ссылаются на неизменные объекты, так  что переменные с одинаковыми значениями будут иметь одинаковые id

**Округление:**
```
round(6.5) = 6
round(7.5) = 8
round(-6.5) = -6
```
Функция `round()` в Python работает по принципу **"банковского округления"** (round half to even), что может приводить к неочевидным результатам. Когда число находится **ровно посередине** между двумя целыми (например, 6.5 между 6 и 7), Python округляет его **до ближайшего четного числа**. 
**Зачем так сделано?**  
    Это уменьшает статистическое смещение при массовом округлении (например, в финансах).
`round(7.35, 1) = 7.3` - Здесь возникает проблема **представления чисел с плавающей точкой** в компьютере.  
Число `7.35` **не может быть точно представлено** в двоичной системе, поэтому хранится как приближение (например, `7.3499999999999996`).

**Для точных вычислений** используйте модуль `decimal`
```
from decimal import Decimal, ROUND_HALF_UP

number = Decimal('7.35')
result = number.quantize(Decimal('0.1'), rounding=ROUND_HALF_UP)
print(float(result))  # 7.4
```
**Decimal, Fraction**
```
from decimal import Decimal
>>> Decimal("0.1") + Decimal("0.2") == Decimal("0.3")
True
>>> Decimal(1) / Decimal(7)
Decimal('0.1428571428571428571428571429')
>>> from fractions import Fraction
>>> Fraction(1, 10)
Fraction(1, 10)
>>> Fraction(1, 10) + Fraction(2, 10) == Fraction(3, 10)
True
```

## Базовые типы:  строки
s = "просто строка" # str
byte_s = b"qwerty" # bytes
raw_s = r"111\nданные" # str

str.encode() -> bytes
bytes.decode() -> str

Некоторые методы:

1. S.find(str, [start],[end]) - Поиск подстроки в строке. Возвращает номер первого вхождения или -1.
2. S.rfind(str, [start],[end]) - Поиск подстроки в строке. Возвращает номер последнего вхождения или -1
3. S.index(str, [start],[end]) - Поиск подстроки в строке. Возвращает номер первого вхождения или вызывает ValueError
4. S.rindex(str, [start],[end]) - Поиск подстроки в строке. Возвращает номер последнего вхождения или вызывает ValueError
5. S.isdigit() - Состоит ли строка из цифр
6. S.isalpha() - Состоит ли строка из букв
7. S.isalnum() - Состоит ли строка из цифр или букв
8. S.isspace() - Состоит ли строка из неотображаемых символов (пробел, символ перевода страницы ('\f'), "новая строка" ('\n'), "перевод каретки" ('\r'), "горизонтальная табуляция" ('\t') и "вертикальная табуляция" ('\v'))
9. S.expandtabs([tabsize]) - Возвращает копию строки, в которой все символы табуляции заменяются одним или несколькими пробелами, в зависимости от текущего столбца. Если TabSize не указан, размер табуляции полагается равным 8 пробелам
10. S.swapcase() - Переводит символы нижнего регистра в верхний, а верхнего – в нижний
11. S.zfill(width) - Делает длину строки не меньшей width, по необходимости заполняя первые символы нулями
12. S.ljust(width, fillchar=" ") - Делает длину строки не меньшей width, по необходимости заполняя последние символы символом fillchar
13. S.rjust(width, fillchar=" ") - Делает длину строки не меньшей width, по необходимости заполняя первые символы символом fillchar
```

######  Базовые типы: коллекции
```
1. Список (list)

Некторые методы:
## append(x) - Добавляет элемент в конец списка.
## clear() - Удаляет из списка все имеющиеся в нём значения.
## copy() - Возвращает копию списка.
## count(x) - Возвращает количество вхождений значения в список.
## extend(iterable) - Дополняет список элементами из указанного объекта iterable.
## index(x[, start[, end]]) - Возвращает индекс первого элемента, со значением х.
## insert(i, x) - Вставляет указанный элемент перед указанным индексом в списке.
## pop([i]) - Возвращает элемент на указанной позиции, удаляя при этом его из списка.
## remove(x) -  Удаляет из списка указанный элемент.
## reverse() - Перестраивает элементы списка в обратном порядке.
## sort(key=None, reverse=False) - Сортирует элементы списка.


2. Кортеж (tuple)
3. Словари Dict

## clear() - Удаляет из словаря все имеющиеся в нём элементы.
## copy() - Возвращает копию словаря.
## classmethod dict.fromkeys(seq[, value]) - Создает словарь с ключами из `seq` и значением `value` (по умолчанию `None`).
## get(key[, default]) - Возвращает значение ключа или, если ключа нет в словаре, значение по умолчанию.
## items() - Возвращает последовательность кортежей `(ключ, значение)`.
## keys() - Возвращает ключи словаря в виде последовательности.
## pop(key[, default]) - Удаляет ключ, и возвращает значение. Если ключа нет, возвращает `default` (по умолчанию бросает исключение).
## popitem() - Удаляет и возвращает последнюю добавленную в словарь пару (ключ, значение). Если словарь пуст, бросает исключение `KeyError`.

## setdefault(key[, default]) - Возвращает значение ключа, но если его нет, не бросает исключение, а создает ключ со значением `default` (по умолчанию `None`).
## update([other]) - Обновляет словарь, добавляя пары (ключ, значение) из `other`. Существующие ключи перезаписываются. Возвращает `None` (не новый словарь!).
## values() - Возвращает значения словаря в виде последовательности.

2. Множество (set, frozenset) уникальных неизменяемых объектов.
   Множество не индексируется, но по нему можно итерироваться.

Распаковка:
lst = [1, 2, 3, 4, 5]
a, b, *c = lst # 1, 2, [3, 4, 5]
a, *b, c = lst # 1, [2, 3, 4], 5

d = dict(x=10, y=20) # {"x": 10, "y": 20}
```


###### Изменяемые и неизменяемые типы данных

Неизменяемые
 -  int, float, bool, complex
 -  str, bytes
 -  tuple
 - frozenset
Изменяемые
 -  list
 -  dict, set
 -  user defined

###### Управляющие конструкции: контекстный менеджер
Контекстный менеджер содержит методы `__enter__()` и `__exit__()`. Метод `__enter__()` выполняется перед выполнением блока кода внутри оператора `with`. Он может выполнять какие-либо подготовительные действия или возвращать значение, которое будет связано с переменной после ключевого слова `as`. Метод `__exit__()` вызывается после завершения выполнения блока кода `with`. Он используется для выполнения завершающих действий, таких как освобождение ресурсов, обработка исключений или выполнение финализирующих операций
```
class CtxManager:
	def __init__(self, name):
		self.db = connect_db(name)
	def __enter__(self):
		return self.db
	def __exit__(self, exc_type, exc_val, exc_tb):
		self.db.close()

from contextlib import contextmanager
with CtxManager("db_name") as db:
	do_action(db)
```

Контекстные менеджеры являются важной концепцией в Python, которая обеспечивает удобство, безопасность и эффективность при работе с ресурсами, файлами, базами данных, сетевыми соединениями и другими объектами, требующими специального управления жизненным циклом.

###### Функции: декораторы
Декоратор - это функция, которая принимает функцию и возвращает функцию.
```
def deco(fn):
	def inner(*args, **kwargs):
		print("before", fn.__name__)
		res = fn(*args, **kwargs)
		print("after", fn.__name__)
		return res
	return inner
@deco
def add_nums(a, b):
	return a + b
```
Нужно всегда декорировать  wrapper с помощью `functools.wraps`. Эта функция копирует всю служебную метаинформацию о декорируемой функции в функцию-декоратор (название функции, докстринги, список входящих аргументов, их типы и тд).
```
from functools import wraps

def decorator(func):
	@wraps(func)
	def wrapper(*args, **kwargs):
		return func(*args, **kwargs)
	return wrapper
```


декораторы с параметрами:
```
def deco(add_param):
	def inner_deco(fn):
		def inner(*args, **kwargs):
			return fn(*args, **kwargs) + add_param
		return inner
	return inner_deco

@deco(45)
def add_nums(a, b):
	return a + b
	
add_nums = deco(add_nums)
```


###### Итераторы
Итератор представляет собой объект-перечислитель, который для данного объекта
выдает следующий элемент, либо вызывает исключение, если элементов больше нет.
```
class SpecialIterator:
	def __init__(self, limit):
		self.limit = limit
		self.counter = 0

	def __next__(self):
		if self.counter < self.limit:
			self.counter += 1
			return self.counter
		else:
			raise StopIteration
```
###### Генераторы
Генератор – функция, которая при вызове next() возвращает следующий объект по
алгоритму ее работы. Вместо return в генераторе используем yield (или вместе).
```
def gen(count):
	while count > 0:
		yield count
		count -= 1
	return count # будет аргументом StopIteration
```

###### Классы
```
class A:
	cls_attr = 42
	def __init__(self, val):
		self.val = val
		self._protected = 10
		self.__private_val = 20
	
	def print_name(self):
		print(self.__class__.__name__)

	@property
	def private_val(self):
		return self.__private_val
```

##### Встроенный функции
1. `map(function, iterable, [iterable 2, iterable 3, ...])` - применяет указанную функцию к каждому элементу указанной последовательности/последовательностей. 
Пример:
```
def func(el1, el2):
	return '%s|%s' % (el1, el2)
list(map(func, [1, 2], [3, 4, 5])) # ['1|3', '2|4']
```

2. `reduce(function, iterable[, initializer])` (из `functools`) - применяет функцию к элементам последовательности, сводя её к единственному значению. 
   Пример: 
```
from functools import reduce
sum_all = reduce(lambda x,y: x + y, [1, 2, 3], 10) # sum_all = 16,начальное значение 10
```
3. `filter(function, iterable)` - предлагает элегантный вариант фильтрации элементов последовательности. Принимает в качестве аргументов функцию и последовательность, которую необходимо отфильтровать. 
```
def is_even(x):
	return x % 2 == 0:
>>> print(list(filter(is_even, [1, 3, 2, 5, 20, 21])))  # [2, 20]
```
4. `zip` - объединяет в кортежи элементы из последовательностей 
   переданных в качестве аргументов.
```
>>> a = [1,2,3]
>>> b = "xyz"
>>> c = (None, True)
>>> print(list(zip(a, b, c)))
[(1, 'x', None), (2, 'y', True)]
```
5. `compile(source, filename, mode, flag, dont_inherit, optimize)` - выполняет код, написанный в виде текста (можно передавать строку - source, либо написать код в текстовом файле и указать путь до него filename)
```
>>> x = compile('x = 1\nz = x + 5\nprint(z)', 'test', 'exec')
>>> exec(x)
# 6
# выполнение в eval
>>> y = compile("print('4 + 5 =', 4+5)", 'test', 'eval')
>>> eval(y)
# 4 + 5 = 9
```
6. `exec(obj[, globals[, locals]]) -> None` - динамически исполняет указанный код.
```
prog = 'print("The sum of 5 and 10 is", (5+10))'
exec(prog) # The sum of 5 and 10 is 15
```

7. string module:
```
string.digits - '0123456789'
string.hexdigits - '0123456789abcdefABCDEF'
string.punctuation - '!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~'
string.ascii_lowercase - 'abcdefghijklmnopqrstuvwxyz'
string.ascii_uppercase - 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
string.ascii_letters - все буквы (латиница)
string.printable - cтрока символов ASCII, которые Python считает печатаемыми.
string.whitespace - Строка, содержащая все символы ASCII, которые считаются пробелами. Сюда входят символы пробел, табуляция, перевод строки, возврат, перевод формы и вертикальная табуляция.
```
