

###### Управляющие конструкции: контекстный менеджер
Контекстный менеджер содержит методы `__enter__()` и `__exit__()`. Метод `__enter__()` выполняется перед выполнением блока кода внутри оператора `with`. Он может выполнять какие-либо подготовительные действия или возвращать значение, которое будет связано с переменной после ключевого слова `as`. Метод `__exit__()` вызывается после завершения выполнения блока кода `with`. Он используется для выполнения завершающих действий, таких как освобождение ресурсов, обработка исключений или выполнение финализирующих операций
```
class CtxManager:
	def __init__(self, name):
		self.db = connect_db(name)
	def __enter__(self):
		return self.db
	def __exit__(self, exc_type, exc_val, exc_tb):
		self.db.close()

from contextlib import contextmanager
with CtxManager("db_name") as db:
	do_action(db)
```

Контекстные менеджеры являются важной концепцией в Python, которая обеспечивает удобство, безопасность и эффективность при работе с ресурсами, файлами, базами данных, сетевыми соединениями и другими объектами, требующими специального управления жизненным циклом.

Пример:
```
import time

class Timer:
    def __enter__(self):
        self.start = time.time()

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.end = time.time()
        print(f'Время выполнения: {self.end - self.start:.2f} секунд')

with Timer():
    # код, время выполнения которого нужно измерить
    time.sleep(2)
```
 Можно использовать декоратор `contextlib.contextmanager` для создания контекстного менеджера с помощью генератора.
```
import time
from contextlib import contextmanager

@contextmanager
def timer():
    start = time.time()
    try:
        yield
    finally:
        end = time.time()
        print(f'Время выполнения: {end - start:.2f} секунд')

with timer():
    # код, время выполнения которого нужно измерить
    time.sleep(2)
```


# Files

При открытии файла операционная система возвращает специальный дескриптор файла (идентификатор), однозначно определяющий, с каким файлом далее будут выполняться  операции.
В Python работа с файлами осуществляется через специальный абстрактный файловый
объект. В зависимости от способа создания такого объекта, он может быть привязан как к физическому файлу на диске, так и другому устройству, поддерживающему схожие  операции (стандартный ввод/вывод и пр.).
`open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)`
###### кодировка
import locale
locale.getpreferredencoding(False)

Вот описание каждого метода файловых объектов в Python:

---

### 1. **`file.close()`**
Закрывает файл, освобождая системные ресурсы. После этого все операции с файлом становятся невозможны. Рекомендуется использовать менеджер контекста (`with open(...) as file`), чтобы автоматически закрывать файл.

---

### 2. **`file.fileno()`**
Возвращает целочисленный **дескриптор файла** (file descriptor), используемый на низком уровне в операционной системе. Полезен для интеграции с модулями, требующими прямого доступа к дескриптору (например, `os.read()`).

---

### 3. **`file.flush()`**
Принудительно сбрасывает данные из буфера в файл. В обычном режиме данные могут буферизоваться, но `flush()` обеспечивает их немедленную запись (однако ОС или диск могут сохранять свою буферизацию).

---

### 4. **`file.isatty()`**
Возвращает `True`, если файл привязан к терминалу (tty-устройству), иначе `False`. Например, для `sys.stdin` вернет `True`, если скрипт запущен в консоли.

---

### 5. **`file.next()`**
**Только в Python 2.** Возвращает следующую строку при итерации по файлу. В Python 3 используется встроенная функция `next(file)`.

---

### 6. **`file.read(n)`**
Читает `n` символов (в текстовом режиме) или байт (в бинарном режиме). Если `n` не указано, читает весь файл до конца. Возвращает строку или байты.

---

### 7. **`file.readline()`**
Читает **одну строку** из файла (включая символ `\n`). Если достигнут конец файла, возвращает пустую строку.

---

### 8. **`file.readlines()`**
Читает все строки файла и возвращает их в виде **списка**. Можно указать аргумент `sizehint` для чтения до определенного размера данных.

---

### 9. **`file.seekable()`**
Проверяет, поддерживает ли файл произвольный доступ (т.е. можно ли использовать `file.seek()`). Например, для потоков ввода/вывода (как `sys.stdin`) возвращает `False`.

---

### 10. **`file.tell()`**
Возвращает текущую позицию указателя в файле (в байтах от начала файла в бинарном режиме; в текстовом режиме точное значение зависит от ОС).

---

### 11. **`file.truncate(n)`**
Обрезает файл до `n` байт. Если `n` не указано, обрезает до текущей позиции указателя. После вызова размер файла становится равным `n`.

---

### 12. **`file.write(str)`**
Записывает строку `str` в файл. В текстовом режиме `str` должна быть строкой, в бинарном — объектом `bytes`. Возвращает количество записанных символов/байт.

---

### 13. **`file.writelines(sequence)`**
Записывает элементы последовательности `sequence` (списка, генератора и т.д.) в файл. **Не добавляет** символы перевода строки — их нужно указывать явно в каждой строке.

---

### Важно:
- В бинарном режиме (`'b'`) работают с байтами, в текстовом — со строками.
- После закрытия файла (`close()`) методы объекта файла вызывать нельзя.
- Для итерации по строкам файла в Python 3 используйте `for line in file: ...`.