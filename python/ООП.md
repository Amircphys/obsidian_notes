### Методы классов. Параметр self
Когда мы вызываем методы класса через его объекты, то интерпретатор Python автоматически добавляет первым аргументом ссылку на объект, из которого этот метод вызывается. Поэтому, если мы хотим внутри класса определить метод, который можно было бы вызывать из его экземпляров, то дополнительно прописывается первый параметр, обычно, с именем self:
```python
class Point:
    color = 'red'
    circle = 2
 
    def set_coords(self):
        print("вызов метода set_coords " + str(self))
```
Параметр self будет ссылаться на экземпляр класса, из которого вызывается метод. Когда метод вызывается через класс, то Python автоматически не подставляет никаких аргументов. А когда вызов идет через экземпляры класса, то первый аргумент – это всегда ссылка на экземпляр. Данный момент нужно знать и помнить. Так зачем понадобилось такое поведение? Дело в том, что метод класса – это тоже его атрибут и когда создаются экземпляры класса, то метод становится общим для всех объектов и не копируется в них. Фактически, только благодаря параметру self мы «знаем» какой объект вызвал данный метод и можем организовать с ним обратную связь.

#### Инициализатор __init__ и финализатор __del__
В каждом классе языка Python есть набор предопределенных «магических» методов. Да, это такое общепринятое название. Магические методы начинаются и заканчиваются двумя подчеркиваниями:

						__ имя метода__

В частности существуют два таких метода:

- __init__(self) –  инициализатор объекта класса
- __del__(self) – финализатор класса

Первый вызывается сразу после создания экземпляра класса, а второй – перед непосредственным его удалением. Давайте посмотрим, как они работают и зачем нужны.
 Вначале происходит создание объекта в памяти устройства. Непосредственно перед его созданием вызывается магический метод __new__ (О нем мы еще будем говорить). Затем, после успешного создания объекта, вызывается магический метод __init__ для начальной инициализации созданного объекта. 
После запуска программы видим, что объект в конце программы действительно был удален и вызван метод __del__. Но, здесь у вас может возникнуть вопрос: а когда и в какой момент вообще происходит удаление объектов. Мы же в программе это явно нигде не указываем? Работает все достаточно просто. Интерпретатор языка Python имеет, так называемый, **сборщик мусора**. Это алгоритм, который отслеживает объекты и как только они становятся ненужными, удаляет их. Но как он определяет нужный объект или ненужный? Все очень просто. Пока на какой-либо объект ведет хотя бы одна внешняя ссылка, то он считается используемым и сохраняется в памяти. Как только все внешние ссылки пропадают, то сборщик мусора его уничтожает (освобождает память, которую он занимал).


### Магический метод __new__. Пример паттерна Singleton

Зачем нужно было определять два разных метода, которые последовательно вызываются при создании экземпляров классов? Разве не достаточно одного `__init__`, чтобы выполнять начальную инициализацию объекта? Конечно, нет. В практике программирования встречаются самые разнообразные задачи и иногда нужно что-то делать и до создания объектов. Например, реализация известного паттерна Singleton в Python, как раз делается через метод `__new__` и мы с ним позже познакомимся.
```python
class Point:
    def __new__(cls, *args, **kwargs):
        print("вызов __new__ для " + str(cls))
 
    def __init__(self, x=0, y=0):
        print("вызов __init__ для " + str(self))
        self.x = x
        self.y = y
```

Смотрите, здесь записан метод `__new__`, у которого первым идет обязательный параметр `cls` – это ссылка на текущий класс Point, а затем, указываются коллекции из фактических и формальных параметров, которые может принимать данная функция.
Если теперь попробовать создать экземпляр класса - то мы в консоли увидим только одно сообщение от метода `__new__`. То есть, второй метод `__init__` не был вызван
Почему так произошло? В Python магический метод `__new__` должен возвращать адрес нового созданного объекта. А в нашей программе он ничего не возвращает, то есть, значение None, что эквивалентно отказу в создании нового объекта. Хорошо, давайте адрес нового объекта. Но откуда мы его возьмем? Для этого можно вызвать аналогичный метод базового класса и делается это, следующим образом:
```python
def __new__(cls, *args, **kwargs):
        print("вызов __new__ для " + str(cls))
        return super().__new__(cls)
```

Предположим, что мы разрабатываем класс для работы с БД. В частности, через него можно будет подключаться к СУБД, читать и записывать информацию, закрывать соединение:
```python
class DataBase:
    def __init__(self, user, psw, port):
        self.user = user
        self.psw = psw
        self.port = port
 
    def connect(self):
        print(f"соединение с БД: {self.user}, {self.psw}, {self.port}")
 
    def close(self):
        print("закрытие соединения с БД")
 
    def read(self):
        return "данные из БД"
 
    def write(self, data):
        print(f"запись в БД {data}")
```
И далее полагаем, что в программе должен существовать только один экземпляр этого класса в каждый момент ее работы. То есть, одновременно два объекта класса DataBase быть не должно. Чтобы это обеспечить и гарантировать, как раз и используется паттерн Singleton. Реализуем его для класса DataBase.  Пропишем в нем специальный атрибут (на уровне класса) `__instance = None`, который будет хранить ссылку на экземпляр этого класса. Если экземпляра нет, то атрибут будет принимать значение None. А, затем, чтобы гарантировать создание строго одного экземпляра, добавим в класс магический метод `__new__`:
```python
def __new__(cls, *args, **kwargs):
	if cls.__instance is None:
		cls.__instance = super().__new__(cls)

	return cls.__instance
```

Работает этот метод очевидным образом. Мы проверяем атрибут класса `__instance`. Причем, для обращения к нему используем параметр `cls` – ссылку на текущий класс. Подробнее я еще освещу этот момент. Далее, проверяем, если значение равно None, то вызываем метод `__new__` базового класса и тем самым разрешаем создание объекта. Иначе, просто возвращаем ссылку на ранее созданный экземпляр. И пропишем еще один магический метод – финализатор `__del__`, который будет обнулять атрибут `__instance` перед уничтожением объекта, чтобы мы могли, при необходимости, создать новый.

Все, простейший вариант паттерна Singleton готов. Правда он имеет один изъян. Если попробовать создать два экземпляра: 
```python
db = DataBase('root', '1234', 80)
db2 = DataBase('root2', '5678', 40)
print(id(db), id(db2))
```
то их id ожидаемо будут равны. То есть, ссылки db и db2 действительно ведут на один объект. Но, если выполнить метод:
```python
db.connect()
db2.connect()
```
то увидим значения: 'root2', '5678', 40 – аргументы при повторном создании класса. По идее, если объект не создается, то и локальные свойства его также не должны меняться. Почему так произошло? Все просто. Мы здесь действительно видим первый объект. Но при повторном вызове DataBase() также был вызван магический метод `__init__` с новым набором аргументов и локальные свойства изменили свое значение. Конечно, мы можем здесь поставить «костыль»  и дополнительно в классе прописать флаговый атрибут, например: `__is_exist = False`  специально для метода `__init__`, чтобы не выполнять его если объект уже создан. Но  cлишком уж костыльно получается это. Правильнее было бы здесь переопределить еще один магический метод `__call__`.

### Методы класса (classmethod) и статические методы (staticmethod)
До сих пор мы  определяли методы просто как функции внутри класса, например:
```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def get_coord(self):
        return self.x, self.y
```
И у каждого такого метода, как правило, первым идет параметр self – ссылка на экземпляр класса, из которого метод был вызван:
```
v = Vector(10, 20)
coord = v.get_coord()
print(coord)
```
При вызове метода get_coord () параметр self будет вести на объект v класса Vector.  При вызове такого метода напрямую из класса нужно явно указывать первый аргумент self:
`coord2 = Vector.get_coord(v)`. Так вот, в Python помимо таких «стандартных» методов можно задавать методы уровня класса и статические методы с помощью встроенных декораторов: `@classmethod и @staticmethod`.
```python
class Vector:
	MIN_COORD = 0
	MAX_COORD = 100
    def __init__(self, x, y):
        self.x = x
        self.y = y
 
    def get_coord(self):
        return self.x, self.y
        
    @classmethod
    def validate(cls, arg):
        return cls.MIN_COORD <= arg <= cls.MAX_COORD
```

Обратите внимание, у методов класса (когда мы используем декоратор classmethod) первым параметром идет `cls` – ссылка на класс, а не `self` – ссылка на объект класса. Это означает, что данный метод может обращаться только к атрибутам текущего класса, но не к локальным свойствам его экземпляров. Мало того, этот метод можно теперь напрямую вызывать из класса, не передавая ссылку на экземпляр, как это было при вызове обычных методов через класс:
```python
res = Vector.validate(5)
print(res)
```

Здесь пользователь класса Vector может совершенно спокойно вызывать метод validate(), не создавая никаких объектов. Но «платой» за это является ограниченность метода: он может работать только с атрибутами класса, но не объекта, что, в общем то, естественно, так как у него изначально нет ссылки на объект. Во всем остальном этот метод работает абсолютно также, как и любой другой метод, объявленный в классе. Давайте мы им воспользуемся и вызовем внутри класса для проверки корректности координат x, y:
```python
    def __init__(self, x, y):
        self.x = self.y = 0
        if Vector.validate(x) and Vector.validate(y):
            self.x = x
            self.y = y
```

Обратите внимание, мы здесь обращаемся к методу класса через пространство имен Vector. Но также можем прописать и self:
```python
if self.validate(x) and self.validate(y):
```
Наконец, третий тип методов – статические методы, определяются декоратором @staticmethod. Это методы, которые не имеют доступа ни к атрибутам класса, ни к атрибутам его экземпляров, то есть, некая независимая, самостоятельная функция, объявленная внутри класса. Обычно, это делают для удобства, т.к. их функционал так или иначе связан с тематикой класса.

Например, в нашем классе Vector можно объявить такой статический метод, который бы вычислял квадратичную норму вектора (длину вектора в квадрате):
```python
@staticmethod
def norm2(x, y):
	return x*x + y*y
```

Подведем итог различных типов методов в классах. Обычные методы, как правило, вызываются из экземпляров классов и работают с атрибутами экземпляров и атрибутами классов. Методы классов обычно вызываются через класс, реже через его экземпляры и имеют доступ только к атрибутам самого класса, в котором объявлены. Наконец, статические методы – это совершенно изолированные функции, которые работают только с параметрами, прописанными в ней самой и не имеют доступа к атрибутам класса или его экземпляров.

Поэтому, если вам нужен метод, который работает с атрибутами объектов класса, то это обычное определение функций внутри класса с первым параметром self. Если метод работает только с атрибутами класса, то возможно, имеет смысл его определить как метод класса и тогда можно будет вызывать без ссылки на объект этого класса. Третий тип, статические методы часто определяют как вспомогательные, сервисные, связанные с логикой работы самого класса.


### Примеры  использования @classmethod

**@classmethod** — это метод, который принадлежит не конкретному объекту (экземпляру), а всему классу. Вместо `self` он принимает `cls` — ссылку на сам класс.
##### 1. Альтернативные конструкторы
Представь, что у тебя есть класс `Person`, и ты хочешь создавать объекты разными способами:

```python
class Person:
	def __init__(self, name, age):
		self.name = name
		self.age = age
		# Обычный способ создания
		# person = Person("Иван", 25)
	
		# Альтернативный конструктор из строки
		@classmethod
		def from_string(cls, person_str):
			name, age = person_str.split('-')
			return cls(name, int(age)) # cls это то же что Person
	
		# Альтернативный конструктор для младенца
		@classmethod
		def baby(cls, name):
			return cls(name, 0)

# Использование:
person1 = Person("Анна", 30) # обычный способ
person2 = Person.from_string("Иван-25") # из строки
person3 = Person.baby("Маша") # младенец
print(person2.name, person2.age) # Иван 25
print(person3.name, person3.age) # Маша 0
```
##### 2. Работа с общими данными класса
```python
class User:
	total_users = 0 # общий счётчик для всех пользователей

	def __init__(self, username):
		self.username = username
		User.total_users += 1

	@classmethod
	def get_total_users(cls):
		return cls.total_users

	@classmethod
	def reset_counter(cls):
		cls.total_users = 0

# Использование:
user1 = User("alice")
user2 = User("bob")
print(User.get_total_users()) # 2 - можем вызвать без создания объекта!
User.reset_counter()
print(User.get_total_users()) # 0
```

##### Главные преимущества:
1. **Вызов без объекта**: `Person.from_string("Иван-25")` — не нужно сначала создавать объект
2. **Альтернативные способы создания**: один класс, много способов его создать
3. **Работа с классом в целом**: счётчики, общие операции
##### Простая аналогия:
Представь класс как **завод по производству машин**:
- Обычный метод (`self`) — это то, что делает конкретная машина
- @classmethod (`cls`) — это то, что делает сам завод (создаёт машины особым способом, ведёт статистику производства)

```python
class Car:
	produced_cars = 0
	def __init__(self, model):
		self.model = model
		Car.produced_cars += 1

	def drive(self): # обычный метод - что делает машина
		return f"{self.model} едет"

	@classmethod
	def get_production_stats(cls): # что делает завод
		return f"Произведено машин: {cls.produced_cars}"

	@classmethod
	def create_luxury_car(cls): # завод создаёт машину особым способом
		return cls("Mercedes S-Class")

# Машина что-то делает:
car = Car("Toyota")
print(car.drive()) # Toyota едет
# Завод что-то делает:
print(Car.get_production_stats()) # Произведено машин: 1
luxury = Car.create_luxury_car()
print(Car.get_production_stats()) # Произведено машин: 2
```



