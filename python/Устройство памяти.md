Представьте, что вы архитектор, проектирующий дом. Вы выбираете материалы, планируете комнаты, но... кто-то уже подвез кирпичи, цемент и даже расставил мебель. Звучит идеально? Примерно так Python обращается с памятью: он берет на себя рутину, чтобы вы могли сосредоточиться на логике приложения. Но что, если дом нужно перестроить или добавить нестандартный этаж? 
Когда вы пишете `x = [1, 2, 3]`, Python не заставляет вас думать, сколько байт нужно выделить под список. Он сам находит «свободное место» в памяти, резервирует его и следит, чтобы объект жил ровно столько, сколько требуется. Это как строительная бригада, которая не только привозит материалы, но и убирает мусор после ремонта. В основе этого процесса лежит менеджер памяти, который работает с private heaps (приватными кучами). Каждый объект в Python — это структура, которая содержит: 

- тип данных (например, int, list); 
- счетчик ссылок; 
- значение объекта. 

Например, для списка [1, 2, 3] выделяется память не только под элементы, но и под служебную информацию (размер, указатели). Это напоминает упаковку товара в коробку: сам товар, плюс этикетки и амортизация. 

Объекты в Python можно сравнить с воздушными шарами, которые держат за ниточки. Пока кто-то держит нить (есть ссылка на объект), шарик на месте. Когда нити отпускают — он улетает (память освобождается). Именно так работает счетчик ссылок. 

В CPython (стандартной реализации Python) каждый объект содержит поле ob_refcnt, которое отслеживает количество ссылок. Когда вы создаете переменную, назначаете ее другой переменной или удаляете, это поле меняется.

```python
a = [1, 2, 3]  # ob_refcnt = 1 
b = a          # ob_refcnt = 2 
del a          # ob_refcnt = 1 
b.append(4)    # Счетчик не меняется -- меняется содержимое объекта 
b = None       # ob_refcnt = 0 → объект удален 
```
Стоит использовать sys.getrefcount(), чтобы посмотреть текущий счетчик ссылок. Однако учтите, что сам вызов функции увеличит счетчик на 1.

##### Сборщик мусора: детектив, который находит «забытые» объекты

Сборщик мусора (Garbage Collector, GC) — это как уборщик, который обходит «комнаты» памяти и ищет объекты без внешних ссылок. Он находит циклические зависимости с помощью алгоритма поколений (Generational GC). 
Python делит объекты на три поколения: 

- Поколение 0: Новые объекты. Проверяются чаще всего. 
- Поколение 1: Объекты, пережившие одну проверку. 
- Поколение 2: «Долгожители». Проверяются реже. 

Так сделано, потому что исследования показывают, что большинство объектов «умирают» молодыми. Проверяя молодое поколение чаще, Python экономит ресурсы.
В «Поколение 2» в основном попадают долгоживущие объекты, например глобальные переменные и данные, используемые на протяжении всей работы программы. Поскольку сборщик мусора реже проверяет это поколение, важно контролировать количество и объем таких переменных. Их стоит использовать осознанно, избегая хранения в них больших или редко используемых данных.

Настроить и управлять порогами сборки можно через модуль gc:
```python
import gc  
gc.set_threshold(700, 10, 10)  # Пороги для поколений 0, 1, 2 
```
Пример циклической ссылки:
```python
class Node:     
	def init(self):         
		self.parent = None  
# Создаем узлы-близнецы 
child = Node() 
parent = Node()  
# Замыкаем ссылки 
child.parent = parent 
parent.child = child  # Цикл!  
# Удаляем внешние ссылки 
child = None 
parent = None  
# Теперь GC обнаружит, что объекты недостижимы, и удалит их 
```

Если ваш код создает много циклических ссылок, периодически вызывайте `gc.collect()` вручную.

Garbage Collector в Python отслеживает циклические ссылки не для всех объектов, а только для тех, которые потенциально могут их содержать. К таким объектам относятся контейнерные типы, например словари (dicts), списки (lists), множества (sets), а также экземпляры пользовательских классов. Примитивные типы, такие как числа (int, float) и строки (str), не участвуют в проверке на цикличность, поскольку не могут образовывать циклические зависимости. Это позволяет GC работать эффективнее, фокусируясь только на потенциально проблемных участках памяти.

##### Как оптимизировать память вручную, когда автоматики недостаточно 

Иногда «строительная бригада» Python работает неидеально. Например, если вы создаете миллионы объектов или работаете с большими данными.
Для решения этой проблемы есть несколько способов.

 `__slots__`: когда словари слишком тяжелы 

Каждый объект в Python хранит атрибуты в словаре dict, что гибко, но неэкономно. 
`__slots__` заменяет словарь на фиксированный набор атрибутов, экономя до 40% памяти. 
```python
class User:     
	def init(self, name, age):         
		self.name = name         
		self.age = age  
class SlotUser:     
	slots = ['name', 'age']     
	def init(self, name, age):         
		self.name = name         
		self.age = age  
# Память для 100_000 объектов: 
# Обычный класс: ~15 МБ 
# Класс с slots: ~8 МБ 
```

У этого способа есть пара ограничений. Во-первых, с ним нельзя добавлять новые атрибуты. А, во-вторых, наследование требует аккуратности: если родитель имеет `__slots__`, потомок должен его переопределить. 

Лучше всего `__slots__`  подходит для классов, которые создаются миллионами, например, узлы дерева, элементы списка и подобные.