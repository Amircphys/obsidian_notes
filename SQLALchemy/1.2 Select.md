
### Выборка всех данных из таблицы


```sql
SELECT * FROM book;
```

```python
from sqlalchemy import select
import pandas as pd
with engine.connect() as conn:
	query = select(book)
	result = conn.execute(query)
result_df = pd.DataFrame(result.fetchall())
```


### Выборка отдельных столбцов
```sql
SELECT title, amount FROM book;
```

```python
with engine.connect() as conn:
	query = select(book.c.title, book.c.author)
	result = conn.execute(query)
	result_df = pd.DataFrame(result.fetchall())
```

### Присвоение новых имен столбцам при формировании выборки
```sql
SELECT title AS Название, author AS Автор
FROM book
```

```python
with engine.connect() as conn:
	query = select(book.c.title.label("book_title"),                                                book.c.author.label("book_author")
	)		
	result = conn.execute(query)
	result_df = pd.DataFrame(result.fetchall())
```





### Выборка данных с созданием вычисляемого столбца
```sql
SELECT title, author, price, amount, price * amount AS total
FROM book;

SELECT title, price, ROUND((price*18/100)/(1+18/100),2) AS tax, ROUND(price/(1+18/100),2) AS price_tax FROM book;
```

```python
from sqlalchemy import func
with engine.connect() as conn:
	query = select(
		book.c.title.label("book_title"),                                                book.c.author.label("book_author"),
		(book.c.amount * book.c.price).label("total")
	)
	result = conn.execute(query)
result_df = pd.DataFrame(result.fetchall())

stmt = select(
	book.c.title,
	func.round(book.c.price, 1).label("rounded_price"), # Округление
	func.ceil(book.c.price).label("ceiling_price"), # Округление вверх
	func.floor(book.c.price).label("floor_price"), # Округление вниз
	func.abs(book.c.price - 40).label("price_diff_abs"), # Абсолютное значение
	func.sqrt(book.c.amount).label("sqrt_amount"), # Квадратный корень
	func.power(book.c.amount, 2).label("amount_squared") # Возведение в степень
)
with engine.connect() as conn:
	result = conn.execute(stmt)
result_df = pd.DataFrame(result.fetchall())
```

### Выборка данных, вычисляемые столбцы, логические функции
```sql
SELECT title, amount, price, IF(amount<4, price*0.5, price*0.7) AS sale 
FROM book;
```


```python
from sqlalchemy import case
price_category = case(
	(book.c.price < 500, "Бюджетная"),
	(book.c.price < 650, "Средняя"),
	(book.c.price < 700, "Дорогая"),
	else_="Премиум"
	).label("price_category")

# Определяем статус наличия
stock_status = case(
	(book.c.amount == 0, "Нет в наличии"),
	(book.c.amount < 5, "Мало"),
	(book.c.amount < 10, "Достаточно"),
	else_="Много"
	).label("stock_status")

# Рекомендация к покупке
recommendation = case(
	((book.c.price < 500) & (book.c.amount > 10), "Рекомендуем купить!"),
	((book.c.price > 500) & (book.c.amount < 5), "Дорого и мало"),
	(book.c.amount == 0, "Недоступно"),
	else_="Обычный товар"
	).label("recommendation")

with engine.connect() as conn:
query = select(
	book.c.title,
	price_category,
	stock_status,
	recommendation
	)
result = conn.execute(query)
pd.DataFrame(result.fetchall())


# булевы выражения
query = select(
	book.c.title,
	book.c.price,
	book.c.amount,
	# Проверяем различные условия
	(book.c.price > 600).label("is_expensive"), # Дорогая ли книга
	(book.c.amount > 10).label("in_stock"), # Есть ли в достатке
	(book.c.price * book.c.amount/9 > 300).label("high_value"), # Высокая общая стоимость
	# Комбинированные условия
	((book.c.price < 500) & (book.c.amount > 8)).label("good_deal"), # Хорошая сделка
	((book.c.price > 500) | (book.c.amount < 5)).label("special_attention") # Требует внимания
)


with engine.connect() as conn:
	result = conn.execute(query)
pd.DataFrame(result.fetchall())
```
