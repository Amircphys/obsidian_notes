
**Работа с метаданными базы данных**  
(Для Core и ORM!)

---

### **Что такое метаданные?**  
**Метаданные** — это «описание данных». В SQLAlchemy это объекты, которые описывают структуру вашей базы: таблицы, колонки, связи.  
- **Core**: Использует `MetaData`, `Table`, `Column`.  
- **ORM**: Использует классы-модели, но под капотом тоже создаёт `Table`.  

**Пример из жизни:**  
Представьте, что `MetaData` — это папка с чертежами всех таблиц вашей базы. Каждый чертёж (`Table`) содержит детали колонок (`Column`).

---

### **Создаём таблицы через Core**  
#### 1. Создаём коллекцию метаданных  
```python
from sqlalchemy import MetaData

metadata_obj = MetaData()  # Это наша "папка" для таблиц
```  

#### 2. Описываем таблицу `user_account`  
```python
from sqlalchemy import Table, Column, Integer, String, ForeignKey

user_table = Table(
    "user_account",       # Название таблицы в БД
    metadata_obj,         # Привязываем к нашей "папке"
    Column("id", Integer, primary_key=True),  # Колонка id (первичный ключ)
    Column("name", String(30)),               # Имя, макс. 30 символов
    Column("fullname", String)                # Полное имя (без ограничений)
)
```  

#### 3. Добавляем таблицу `address` с внешним ключом  
```python
address_table = Table(
    "address",
    metadata_obj,
    Column("id", Integer, primary_key=True),
    Column("user_id", ForeignKey("user_account.id"), nullable=False),  # Ссылка на user
    Column("email_address", String, nullable=False)  # Обязательное поле
)
```  

**Пояснения:**  
- `primary_key=True` — указывает на первичный ключ.  
- `ForeignKey("user_account.id")` — внешний ключ на столбец `id` таблицы `user_account`.  
- `nullable=False` — колонка не может быть пустой (NOT NULL в SQL).  

---

### **Генерируем таблицы в базе данных**  
После описания структуры можно создать таблицы в реальной БД:  
```python
metadata_obj.create_all(engine)  # engine — объект подключения из прошлых разделов
```  
**Что произойдёт:**  
- SQLAlchemy отправит команды `CREATE TABLE` в базу.  
- Учтёт порядок создания (например, `address` создастся после `user_account` из-за внешнего ключа).  

**Совет:** Для реальных проектов используйте миграции (например, **Alembic**), чтобы управлять изменениями схемы со временем.

---

### **Создаём таблицы через ORM (декларативно)**  
В ORM каждая таблица описывается классом. Это удобнее и современнее.  

#### 1. Создаём базовый класс  
```python
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):  # Базовый класс для всех моделей
    pass
```  

#### 2. Описываем модель `User`  
```python
from sqlalchemy.orm import Mapped, mapped_column, relationship
from typing import List, Optional

class User(Base):
    __tablename__ = "user_account"  # Название таблицы

    # Колонки
    id: Mapped[int] = mapped_column(primary_key=True)
    name: Mapped[str] = mapped_column(String(30))
    fullname: Mapped[Optional[str]]  # Может быть None (NULL в БД)

    # Связь с адресами (об этом подробнее позже)
    addresses: Mapped[List["Address"]] = relationship(back_populates="user")

    def __repr__(self):
        return f"User(id={self.id}, name={self.name})"
```  

#### 3. Описываем модель `Address`  
```python
class Address(Base):
    __tablename__ = "address"

    id: Mapped[int] = mapped_column(primary_key=True)
    email_address: Mapped[str]
    user_id = mapped_column(ForeignKey("user_account.id"))  # Внешний ключ

    # Связь с пользователем
    user: Mapped[User] = relationship(back_populates="addresses")

    def __repr__(self):
        return f"Address(email={self.email_address})"
```  

**Пояснения:**  
- `Mapped[int]` — аннотация типа для подсказок IDE.  
- `mapped_column()` — аналог `Column` в ORM.  
- `relationship()` — описание связи между таблицами (подробнее в следующих разделах).  

**Плюсы подхода ORM:**  
- Код чище и ближе к Python.  
- Автоматические подсказки типов в редакторе.  
- Удобно добавлять методы (например, `__repr__`).  

---

### **Отражение существующих таблиц (Reflection)**  
Если таблицы уже есть в базе, их описание можно автоматически получить из БД:  
```python
some_table = Table("some_table", metadata_obj, autoload_with=engine)
```  
**Что произойдёт:**  
- SQLAlchemy запросит структуру таблицы `some_table` из БД.  
- Создаст объекты `Column`, `ForeignKey` и т.д. автоматически.  

**Зачем это нужно:**  
- Работать с существующей базой без ручного описания схемы.  
- Быстро начать использовать SQLAlchemy с legacy-проектами.  

---

### **Советы новичкам**  
1. **Выбор подхода:**  
   - Используйте **ORM**, если работаете с объектами (например, веб-приложение).  
   - Используйте **Core**, если нужен низкоуровневый контроль (сложные запросы, оптимизация).  

2. **DDL-генерация:**  
   - `create_all()` удобен для тестов, но не для продакшена. Для миграций используйте Alembic.  

3. **Типы данных:**  
   - `String(30)` → `VARCHAR(30)` в SQL.  
   - `Mapped[Optional[str]]` → `NULL` разрешён.  

4. **Связи между таблицами:**  
   - Пока просто запомните, что `relationship()` связывает модели. Подробности — в следующем разделе.  

**Пример ошибки:**  
```python
# НЕВЕРНО: Забыли указать primary_key
class User(Base):
    __tablename__ = "user"
    name = mapped_column(String)  # Ошибка! Нет первичного ключа.
```  

Теперь вы можете создавать и описывать таблицы! Следующий шаг — научиться добавлять, изменять и выбирать данные.