**Использование оператора INSERT**  
(Для Core и ORM!)

---

### **Что такое INSERT?**  
Это SQL-команда для добавления новых строк в таблицу. В SQLAlchemy вы можете создавать INSERT-запросы двумя способами:  
- **Core**: Через функцию `insert()`.  
- **ORM**: Через методы объектов, но здесь мы покажем Core.  

**Совет для ORM-пользователей:**  
ORM автоматизирует массовую вставку, но понимание Core полезно для глубокого погружения.

---

### **Создаём INSERT-запрос**  
#### 1. Простой пример  
Добавим пользователя в таблицу `user_account`:  
```python
from sqlalchemy import insert

# Создаём INSERT-запрос
stmt = insert(user_table).values(
    name="spongebob", 
    fullname="Spongebob Squarepants"
)

# Как выглядит SQL?
print(stmt)
# INSERT INTO user_account (name, fullname) VALUES (:name, :fullname)
```  

**Что происходит:**  
- `insert(user_table)` — указываем таблицу.  
- `.values(...)` — задаём значения для колонок.  

#### 2. Выполняем запрос  
```python
with engine.connect() as conn:
    result = conn.execute(stmt)
    conn.commit()

# Проверяем ID новой строки
print(result.inserted_primary_key)  # (1,)
```  
**Логи в консоли:**  
```
BEGIN (implicit)
INSERT INTO user_account (name, fullname) VALUES (?, ?)
[...] ('spongebob', 'Spongebob Squarepants')
COMMIT
```  

---

### **Массовая вставка (много строк сразу)**  
```python
data = [
    {"name": "sandy", "fullname": "Sandy Cheeks"},
    {"name": "patrick", "fullname": "Patrick Star"}
]

with engine.connect() as conn:
    conn.execute(insert(user_table), data)  # Передаём список словарей
    conn.commit()
```  
**Логи:**  
```
BEGIN (implicit)
INSERT INTO user_account (name, fullname) VALUES (?, ?)
[...] [('sandy', 'Sandy Cheeks'), ('patrick', 'Patrick Star')]
COMMIT
```  

**Почему это удобно:**  
- Не нужно писать SQL вручную.  
- SQLAlchemy сам подставляет значения в `VALUES`.  

---

### **Продвинутые фишки**  
#### 1. Возврат данных после вставки (RETURNING)  
Некоторые БД позволяют вернуть данные новой строки (например, ID или значения по умолчанию).  

```python
stmt = insert(address_table).returning(
    address_table.c.id, 
    address_table.c.email_address
)

with engine.connect() as conn:
    result = conn.execute(stmt, {"email_address": "spongebob@sqlalchemy.org"})
    print(result.fetchone())  # (1, 'spongebob@sqlalchemy.org')
```  

**Применимо для:** PostgreSQL, SQLite (3.35+), MSSQL.  

#### 2. Вставка из результата SELECT (INSERT...FROM SELECT)  
Скопируем email-адреса пользователей в таблицу `address`, добавив домен `@aol.com`:  
```python
select_query = select(
    user_table.c.id, 
    user_table.c.name + "@aol.com"  # Конкатенация в SQL
)

insert_stmt = insert(address_table).from_select(
    ["user_id", "email_address"], 
    select_query
)

# Выполняем
with engine.connect() as conn:
    conn.execute(insert_stmt)
    conn.commit()
```  

**Результат в `address`:**  
|  user_id    | email_address                |
|-----------|-------------------------|
| 1               |  spongebob@aol.com    |
| 2               | sandy@aol.com             |  

---

### **Советы и подводные камни**  
- **Автоматические значения:** Если не указать колонки, SQLAlchemy вставит `NULL` или значения по умолчанию.  
  ```python
  # Вставит DEFAULT значения для всех колонок
  stmt = insert(user_table)
  ```  
- **Первичные ключи:** После вставки `result.inserted_primary_key` вернет кортеж с ID (даже для составных ключей).  
- **Подзапросы:** Можно использовать результаты SELECT во вставке.  
  ```python
  # Пример с подзапросом (ищет ID пользователя по имени)
  subquery = select(user_table.c.id).where(user_table.c.name == "spongebob")
  stmt = insert(address_table).values(user_id=subquery.scalar_subquery())
  ```  

---

### **Чеклист для новичка**  
1. Используйте `insert()` для создания запроса.  
2. Передавайте данные в виде словаря или списка словарей.  
3. Не забывайте про `commit()` после изменения данных.  
4. Для возврата данных используйте `.returning()`.  
5. Для сложных вставок применяйте подзапросы и `from_select()`.  

**Ошибка:**  
```python
# НЕВЕРНО: Нет commit() -> данные не сохранятся!
conn.execute(stmt)
```  

Теперь вы умеете добавлять данные в таблицы! Следующий шаг — выборка и обновление данных.