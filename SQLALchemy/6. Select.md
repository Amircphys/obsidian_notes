**Использование оператора SELECT**  
(Для Core и ORM!)

---

### **Основы SELECT-запросов**  
SELECT — это команда SQL для выборки данных из таблиц. В SQLAlchemy вы создаёте запросы через функцию `select()`.  

**Пример для Core:**  
```python
from sqlalchemy import select

# Выбрать всех пользователей с именем 'spongebob'
stmt = select(user_table).where(user_table.c.name == "spongebob")

# Выполнить запрос
with engine.connect() as conn:
    for row in conn.execute(stmt):
        print(row)  # (1, 'spongebob', 'Spongebob Squarepants')
```  

**Пример для ORM:**  
```python
from sqlalchemy.orm import Session

stmt = select(User).where(User.name == "spongebob")

with Session(engine) as session:
    user = session.scalars(stmt).first()
    print(user)  # User(id=1, name='spongebob', ...)
```  

**Различия Core и ORM:**  
- **Core** возвращает кортежи (`Row`).  
- **ORM** возвращает объекты классов (например, `User`).  

---

### **Выбор колонок и таблиц**  
#### 1. Выбор конкретных колонок  
```python
# Core
stmt = select(user_table.c.name, user_table.c.fullname)

# ORM
stmt = select(User.name, User.fullname)
```  

#### 2. Выбор всей таблицы  
```python
# Core
stmt = select(user_table)

# ORM
stmt = select(User)
```  

---

### **Фильтрация (WHERE)**  
Используйте Python-операторы (`==`, `>`, `<` и т.д.) для условий:  
```python
# Пользователи с id > 1
stmt = select(User).where(User.id > 1)

# Комбинирование условий (AND/OR)
from sqlalchemy import and_, or_

stmt = select(User).where(
    or_(
        User.name == "spongebob",
        User.name == "sandy"
    ),
    User.fullname != "Unknown"
)
```  

**Сокращение для ORM:**  
```python
stmt = select(User).filter_by(name="spongebob", fullname="Spongebob Squarepants")
```  

---

### **Сортировка (ORDER BY)**  
```python
# По имени по возрастанию
stmt = select(User).order_by(User.name)

# По fullname по убыванию
stmt = select(User).order_by(User.fullname.desc())
```  

---

### **Группировка и агрегатные функции (GROUP BY / HAVING)**  
```python
from sqlalchemy import func

# Количество адресов у каждого пользователя (только тех, у кого > 1)
stmt = (
    select(User.name, func.count(Address.id).label("address_count"))
    .join(Address)
    .group_by(User.name)
    .having(func.count(Address.id) > 1)
)

# Результат: [('sandy', 2)]
```  

---

### **Соединение таблиц (JOIN)**  
#### 1. Автоматический JOIN по внешнему ключу  
```python
# Core
stmt = select(user_table.c.name, address_table.c.email_address).join(address_table)

# ORM
stmt = select(User.name, Address.email_address).join(Address)
```  

#### 2. Явное указание условия (ON)  
```python
stmt = select(user_table.c.name, address_table.c.email_address).join(
    address_table, user_table.c.id == address_table.c.user_id
)
```  

#### 3. LEFT OUTER JOIN  
```python
stmt = select(User).join(Address, isouter=True)
```  

---

### **Псевдонимы (Aliases)**  
**Зачем:** Чтобы обращаться к одной таблице несколько раз в запросе.  

#### Пример для Core:  
```python
user_alias = user_table.alias()
stmt = select(user_alias.c.name)
```  

#### Пример для ORM:  
```python
from sqlalchemy.orm import aliased

address_alias = aliased(Address)
stmt = select(User).join(address_alias).where(address_alias.email_address == "test@example.com")
```  

---

### **Работа с выражениями и метками**  
#### 1. Использование SQL-функций  
```python
from sqlalchemy import func

# Подсчёт строк
stmt = select(func.count(user_table.c.id))  # SELECT COUNT(user_account.id) ...
```  

#### 2. Метки (LABEL)  
```python
stmt = select((User.name + " - " + User.fullname).label("user_info"))
# SELECT (user_account.name || ? || user_account.fullname) AS user_info ...
```  

#### 3. Текстовые выражения  
```python
from sqlalchemy import text

stmt = select(text("'Статический текст'"), User.name)
```  

---

### **Советы и частые ошибки**  
- **Не забывайте про JOIN:** Если выбираете данные из нескольких таблиц, указывайте условие соединения.  
- **Используйте `label()`:** Для удобства работы с результатами (например, в Pandas DataFrame).  
- **Осторожно с текстовыми запросами:** Избегайте SQL-инъекций, используйте параметры.  

**Ошибка:**  
```python
# НЕВЕРНО: Нет условия JOIN -> декартово произведение!
stmt = select(User.name, Address.email_address)
```  

**Правильно:**  
```python
stmt = select(User.name, Address.email_address).join(Address)
```  

---

### **Чеклист для новичка**  
1. Создайте запрос через `select()`.  
2. Укажите таблицы и колонки.  
3. Добавьте условия через `where()`.  
4. При необходимости отсортируйте (`order_by()`) или сгруппируйте (`group_by()`).  
5. Выполните запрос через `Connection` или `Session`.  

Теперь вы умеете выбирать данные! Следующий шаг — обновление и удаление записей.


**Подзапросы и CTE (Общие табличные выражения)**  

---

### **Что такое подзапросы и CTE?**  
- **Подзапрос (Subquery)** — это SELECT внутри другого запроса. Используется как временная таблица.  
- **CTE (Common Table Expression)** — именованный подзапрос, который можно использовать многократно в одном запросе (как переменную).  

**Пример подзапроса (Core):**  
```python
from sqlalchemy import func

# Подзапрос: количество адресов для каждого пользователя
subq = (
    select(
        func.count(address_table.c.id).label("count"), 
        address_table.c.user_id
    )
    .group_by(address_table.c.user_id)
    .subquery()  # Превращаем в подзапрос
)

# Основной запрос: связываем пользователей с их количеством адресов
stmt = select(
    user_table.c.name, 
    user_table.c.fullname, 
    subq.c.count
).join_from(user_table, subq)
```  

**Результат SQL:**  
```sql
SELECT user_account.name, user_account.fullname, anon_1.count
FROM user_account 
JOIN (
    SELECT count(address.id) AS count, address.user_id 
    FROM address GROUP BY address.user_id
) AS anon_1 
ON user_account.id = anon_1.user_id
```  

**Пример CTE (Core):**  
```python
cte = (
    select(
        func.count(address_table.c.id).label("count"), 
        address_table.c.user_id
    )
    .group_by(address_table.c.user_id)
    .cte(name="address_counts")  # Именованное CTE
)

stmt = select(
    user_table.c.name, 
    user_table.c.fullname, 
    cte.c.count
).join_from(user_table, cte)
```  

**Результат SQL:**  
```sql
WITH address_counts AS (
    SELECT count(address.id) AS count, address.user_id 
    FROM address GROUP BY address.user_id
)
SELECT user_account.name, user_account.fullname, address_counts.count
FROM user_account 
JOIN address_counts ON user_account.id = address_counts.user_id
```  

---

### **Скалярные подзапросы (Scalar Subqueries)**  
Возвращают одно значение (1 строка, 1 столбец). Используются в условиях или SELECT.  

**Пример:**  
```python
# Количество адресов для каждого пользователя (скалярный подзапрос)
subq = (
    select(func.count(address_table.c.id))
    .where(user_table.c.id == address_table.c.user_id)
    .scalar_subquery()  # Делаем подзапрос скалярным
)

# Основной запрос: имена пользователей и количество их адресов
stmt = select(
    user_table.c.name, 
    subq.label("address_count")
)
```  

**Результат SQL:**  
```sql
SELECT user_account.name, 
(SELECT count(address.id) FROM address WHERE user_account.id = address.user_id) AS address_count
FROM user_account
```  

---

### **Коррелированные подзапросы (Correlated Subqueries)**  
Ссылаются на таблицы из внешнего запроса.  

**Пример:**  
```python
subq = (
    select(func.count(address_table.c.id))
    .where(user_table.c.id == address_table.c.user_id)
    .scalar_subquery()
    .correlate(user_table)  # Явно указываем корреляцию
)

stmt = select(
    user_table.c.name, 
    address_table.c.email_address, 
    subq.label("address_count")
).join_from(user_table, address_table)
```  

**Результат SQL:**  
```sql
SELECT user_account.name, address.email_address, 
(SELECT count(address.id) FROM address WHERE user_account.id = address.user_id) AS address_count
FROM user_account JOIN address ON user_account.id = address.user_id
```  

---

### **LATERAL: Подзапросы с доступом к предыдущим таблицам**  
Используется для подзапросов в FROM, которые ссылаются на таблицы из основной части запроса.  

**Пример (PostgreSQL):**  
```python
subq = (
    select(
        func.count(address_table.c.id).label("count"),
        address_table.c.email_address
    )
    .where(user_table.c.id == address_table.c.user_id)
    .lateral()  # Делаем подзапрос LATERAL
)

stmt = select(
    user_table.c.name, 
    subq.c.count, 
    subq.c.email_address
).join_from(user_table, subq)
```  

**Результат SQL:**  
```sql
SELECT user_account.name, anon_1.count, anon_1.email_address
FROM user_account 
JOIN LATERAL (
    SELECT count(address.id) AS count, address.email_address 
    FROM address 
    WHERE user_account.id = address.user_id
) AS anon_1 ON TRUE
```  

---

### **Операции с множествами (UNION, UNION ALL)**  
Объединение результатов нескольких запросов.  

**Пример:**  
```python
from sqlalchemy import union_all

# Два запроса: пользователи с именами 'sandy' и 'spongebob'
stmt1 = select(User).where(User.name == "sandy")
stmt2 = select(User).where(User.name == "spongebob")

# Объединяем через UNION ALL
u = union_all(stmt1, stmt2)

# Исполняем
with Session(engine) as session:
    results = session.scalars(u)
    for user in results:
        print(user)
```  

**Результат SQL:**  
```sql
SELECT user_account.id, user_account.name, user_account.fullname 
FROM user_account 
WHERE user_account.name = 'sandy'
UNION ALL
SELECT user_account.id, user_account.name, user_account.fullname 
FROM user_account 
WHERE user_account.name = 'spongebob'
```  

---

### **EXISTS: Проверка существования записей**  
**Пример: пользователи с хотя бы одним адресом**  
```python
subq = (
    select(Address.id)
    .where(User.id == Address.user_id)
    .exists()  # Превращаем в EXISTS
)

stmt = select(User).where(subq)
```  

**Результат SQL:**  
```sql
SELECT user_account.id, user_account.name, user_account.fullname 
FROM user_account 
WHERE EXISTS (SELECT address.id FROM address WHERE user_account.id = address.user_id)
```  

**Пример: пользователи без адресов (NOT EXISTS)**  
```python
subq = (
    select(Address.id)
    .where(User.id == Address.user_id)
    .exists()
)

stmt = select(User).where(~subq)  # Отрицание EXISTS
```  

---

### **Работа с SQL-функциями**  
**Примеры встроенных функций:**  
```python
from sqlalchemy import func

# COUNT
stmt = select(func.count()).select_from(user_table)

# LOWER (приведение к нижнему регистру)
stmt = select(func.lower(User.name))

# NOW (текущее время)
stmt = select(func.now())
```  

**Оконные функции (Window Functions):**  
```python
# Нумерация адресов для каждого пользователя
stmt = select(
    func.row_number().over(
        partition_by=User.id,  # Группировка по пользователю
        order_by=Address.id    # Сортировка внутри группы
    ),
    User.name,
    Address.email_address
).join(Address)
```  

**Результат SQL:**  
```sql
SELECT 
    row_number() OVER (PARTITION BY user_account.id ORDER BY address.id) AS anon_1,
    user_account.name,
    address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
```  

---

### **Табличные функции (JSON, ARRAY и др.)**  
**Пример: разбор JSON в PostgreSQL**  
```python
json_data = func.json_each('{"a": 1, "b": 2}').table_valued("key", "value")
stmt = select(json_data.c.key, json_data.c.value)
```  

**Результат SQL:**  
```sql
SELECT key, value 
FROM json_each('{"a": 1, "b": 2}')
```  

---

### **Приведение типов (CAST и type_coerce)**  
**CAST:**  
```python
from sqlalchemy import cast, String

# Приведение id к строке
stmt = select(cast(User.id, String))
```  

**type_coerce (без CAST в SQL):**  
```python
from sqlalchemy import type_coerce, JSON

# Указываем, что строка должна трактоваться как JSON
data = type_coerce('{"key": "value"}', JSON)
stmt = select(data["key"])  # Используем JSON-оператор
```  

---

### **Итоги**  
- **Подзапросы и CTE** помогают структурировать сложные запросы.  
- **Скалярные подзапросы** возвращают одно значение.  
- **LATERAL** позволяет подзапросам ссылаться на таблицы из внешнего запроса.  
- **UNION/EXISTS** — мощные инструменты для работы с множествами.  
- **SQL-функции и оконные функции** расширяют возможности анализа данных.  
- **Приведение типов** важно для работы с разными форматами данных.  

**Совет:** Используйте CTE для улучшения читаемости сложных запрос