
---

### **Основные объекты: Connection, Result, Session**  
- **Connection** — подключение к базе для выполнения SQL-запросов.  
- **Result** — результат запроса (например, строки таблицы).  
- **Session (ORM)** — аналог Connection в ORM. Управляет транзакциями и объектами.  

**Совет для ORM-пользователей:**  
Даже в ORM важно понимать, как работают Connection и транзакции. Session внутри использует те же механизмы.

---

### **Подключение к базе (Connection)**  
Используйте контекстный менеджер (`with`), чтобы автоматически закрывать подключение:  
```python
from sqlalchemy import text

with engine.connect() as conn:
    result = conn.execute(text("SELECT 'Hello World'"))
    print(result.all())  # [('Hello World',)]
```  
- **Что происходит:**  
  - `BEGIN (implicit)` — неявное начало транзакции (DBAPI автоматически стартует её при первом запросе).  
  - После выполнения блока — автоматический `ROLLBACK`, если не было коммита.  

---

### **Как сохранять изменения? Коммит!**  
По умолчанию, изменения не сохраняются автоматически. Используйте **явный коммит**.  

**Стиль 1: "Коммить вручную" (commit as you go)**  
```python
with engine.connect() as conn:
    conn.execute(text("CREATE TABLE users (id INT, name TEXT)"))
    conn.execute(text("INSERT INTO users VALUES (1, 'Alice')"))
    conn.commit()  # Сохраняем изменения!
```  

**Стиль 2: "Одна транзакция" (begin once)**  
```python
with engine.begin() as conn:  # Автоматический коммит при успехе, откат при ошибке
    conn.execute(text("INSERT INTO users VALUES (2, 'Bob')"))
```  
**Совет:** Лучше использовать `begin()`, если весь блок должен быть одной транзакцией.

---

### **Как получить данные из Result?**  
Результат запроса — объект `Result`. Способы доступа к данным:  
```python
result = conn.execute(text("SELECT x, y FROM some_table"))

# 1. Как кортежи
for x, y in result:
    print(x, y)

# 2. По индексу
for row in result:
    print(row[0], row[1])

# 3. По имени атрибута
for row in result:
    print(row.x, row.y)

# 4. Как словарь
for row in result.mappings():
    print(row["x"], row["y"])
```

---

### **Параметры в запросах: защита от SQL-инъекций**  
**Всегда передавайте параметры отдельно!**  
```python
# Безопасно (параметр :y)
result = conn.execute(
    text("SELECT * FROM some_table WHERE y > :y"), 
    {"y": 5}  # Подставляется в запрос
)

# Опасно (значение в строке) - НЕ ДЕЛАЙТЕ ТАК!
conn.execute(text("SELECT * FROM users WHERE name = 'Alice'"))  
```  

**Множественные параметры (execute many):**  
```python
data = [{"x": 10, "y": 20}, {"x": 30, "y": 40}]
conn.execute(
    text("INSERT INTO some_table (x, y) VALUES (:x, :y)"),
    data  # Вставит две строки
)
conn.commit()
```  

---

### **ORM: Работа с Session**  
`Session` в ORM работает похоже на `Connection`:  
```python
from sqlalchemy.orm import Session

with Session(engine) as session:
    # Выполнение запроса
    result = session.execute(text("SELECT * FROM users"))
    for row in result:
        print(row)

    # Коммит изменений
    session.execute(text("UPDATE users SET name = 'Bob' WHERE id = 1"))
    session.commit()
```  

**Ключевые моменты:**  
- `Session` автоматически получает новое подключение из `Engine`, когда нужно.  
- Паттерны работы с транзакциями те же, что и в Core.  

---

### **Чеклист для новичка**  
1. Всегда используйте контекстный менеджер (`with`) для Connection/Session.  
2. Явно коммитьте изменения (`commit()`), если не используете `begin()`.  
3. Никогда не вставляйте значения напрямую в SQL-строку — используйте параметры.  
4. Для вставки множества строк передавайте список словарей.  
5. В ORM Session работает аналогично Core Connection — не бойтесь использовать его.  

**Пример ошибки:**  
```python
# НЕВЕРНО! Риск SQL-инъекции.
conn.execute(text(f"SELECT * FROM users WHERE name = '{name}'"))

# ВЕРНО!
conn.execute(text("SELECT * FROM users WHERE name = :name"), {"name": name})
```  

Удачи в освоении транзакций! Следующий шаг — изучение Expression Language и ORM-моделей.