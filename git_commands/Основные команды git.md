`git config user.name "AbdullaevG"` - установить название пользователя
`git config user.email abd.gm90@yandex.ru` - установить почту пользователя

`git config --list`

`git config --unset user.name`  - удалить название пользователя
`git config --unset user.email`- удалить почту пользователя

`git config --global core.editor` - текстовый редактор для git

`git config --global alias.con config  - alias`, заменить команду на свое короткое название, теперь вместо config -> con

`git config -h`

`git help config` (/ поиск текста, n - вперед, shift+n - назад)

`git show <commit id>` -  показать изменения определенного коммита

`git commit --author='AbdullaevG <abd.gm90@yandex.ru>' --date='...'`

`.gitkeep` - данным файлом обычно заполняют пустую диркекторию, которую мы хотим закомитить

`git reset HEAD <path>` - удалить из индексируемых файл 

`touch .gitignore`

`git add -f <path> - force path`

Commit early, commit often

`git add -p `

`git commit -am "message"` - добавляет в индекс все изменненные файлы, которые отслеживаются (есть в индексе)

`git commit -m 'messge' <<file_paths>>` - сразу коммитим файл file_paths, остальные изменения останутся не тронутыми

Удаление файла:
	1. удаляем файл, потом` git add removed_file_path_path`
	2.` git rm -r src`
	3. `git rm -r --cached src` - удаляет из отслеживаемых папок, но сама папка не удаляется
	4. `git rm -f src` - удаляет  даже если есть незакомиченные изменения в удаляемых файлах
	

## ВЕТКИ 
Тематические ветки:
![[Pasted image 20250311213206.png]]


Одновременная поддержка нескольких версий проекта (релиз ветки):
![[Pasted image 20250311213411.png]]
![[Pasted image 20250311213501.png]]


.git/refs/heads/master - путь к ветке master
./git/regs/HEAD - путь к текущей ветке (в даннном файле храниться ссылка на текущую ветку)
Когда мы делаем git commit, гит смотрит head - на какой же мы ветке находимся, далее гит создает новый коммит со свооим идентификатором, но туда же записывает - на базе какого коммита он был построен. Вершина для ветки перемешается к новому коммиту (ссылка мастер)

`git branch` - список веток
`git branch -v` - список веток с коммитами, на которых данные ветки
`git branch new_branch` - новая ветка new_branch

`git checkout -b new_branch` - создание и переключение на новую ветку (новая ветка будет с такими же коммитами как и исходная)

`git branch -v` - инфо о ветках

`git checkout -f master` - перейти на ветку  master и потерять незакомиченные изменения

`git checkout -f HEAD` - удалить все незакомиченные изменения

`git stash` - собирает незакомиченные изменения удаляет их из файлов и архивирует в гит 
 
`git stash pop` - возвращает незакомиченные изменения  (ОПАСНО, не привязано к определенной ветке)

`git checkout -b myFeature dev` - создать ветку myFeature на основе  dev и перейти в нее.

Не всякие незакомиченные изменения приводят к ошибке при checkout. Проблема возникает только если изменения находятся в файлах, которые различаются между ветками, т.е. в файлах которые гиту необходимо заменить при переходе из одной ветки в другую. Если же мы добавили код только в файл, который одинаковый в двух ветках то при checkout не выйдет ошибки, и незакомиченные изменения перенесутся в новую ветку. Так работа сделанная в одной ветке может случайно попасть в другую ветку. 

Мы добавили некий код в master и поняли что лучше надо создать новую ветку и все 
изменения внести уже в нее. Это делается просто -  `git checkout -b fix` - все незакомиченные изменения перейдут туда же. 

Мы сделали несколько коммитов в ветке master и потом с опозданием поняли, что нужно было создавать новую ветку и в ней уже делать изменения:
Сначала нужно создать ветку на текущем коммите - `git branch fix`.
Далее нужно передвинуть master назад - в результате последние коммиты окажутся только в веткуе fix:
![[Pasted image 20250311223433.png]]

откатить ветку master к начальному виду: 
	 1. перейти на другую ветку: `git checkout fix`
	 2. `git branch -f master <id_commit>`  
Если передумали - передвинуть master обратно -  `git branch -f master fix 
можно b такой командой  - `git checkout -B master <id commtia>` - (флаг -B откатывает изменения если ветка master уже существует)
    	
    	
`git checkout <id_commit>` - перейти к отдельному коммиту. Но это приводит к отдаленному состоянию 'detached HEAD'. Т.е. в head находится не ветка, а ссылка на этот коммит:
![[Pasted image 20250311224659.png]]
 Это и есть отдаленное состояние head. Если мы добавим новые коммиты - то для них родителем станет исходный коммит - к которому мы прикрепили head:
 ![[Pasted image 20250311224916.png]]
Особенность таких коммитов в том, что они не участвуют далее в разработке, если мы перейдем теперь одратно на fix - коммиты которые мы сделали как-бы подвисают, к ним сложно обращаться, так как они не находтся на конкретной ветке. Кроме того такие коммиты гит удаляет - они как бы недостижимы по названию ветки. 

Можно забрать изменения сделанные на одной ветке на другую: `git cherry-pick <id_commit>`.

Откатить файлы к предыдцщим версиям:
`git checkout <id commit> file_path `- возврат отдельного файла к прошлому состоянию 
`git checkout HEAD file_path` - отменить все изменения в файле
Если назание файла или директории совпадает с названием ветки или коммита и нам нужно откатить изменения для файла - `git checkout -- folder_name`
```
git push -d <remote_name> <branchname>   # Delete remote
git branch -d <branchname>               # Delete local
```

**Просмотр истории и старых файлов:**

`git log --oneline` 
`git log <branch_name> --oneline`
`git show <id commit>`
`git show HEAD~` - родитель коммита 
`git show HEAD~3` - родитель коммита на три уровня назад (есть сокращение `git show @~3)`
`git checkout @~ index.html` - вернуть версию файла на один коммит назад от head
`git show @~:index.html`  - посмотреть версию файла на один коммит назад
`git show :/sayBye` - найти свежий коммит с таким словом из описания


**Слияние веток**
Нам нужно слить ветку fix c master(main):
	`git checkout master`
	`git merge fix`
Метод слияние - fast forward - самый простой метод, переносит HEAD с master на fix
Отменить слияние:
	`git branch -f master ORIG_HEAD` (в файле `.git/ORIG_HEAD` храниться commit_id)
	`git checkout master`
Можно просто пересоздать ветку master:
	 `git checkout -B master fix` - пересоздать master на основе fix, тоже самое что и merge методом fast forward

**Удаление веток**
`git branch -d fix` - удалить ветку fix (если ветка была слита уже с master)
`git branch -D feature` - удалить ветку feature, которыя не слита с master
А если нам нужно восстановить удаленную неслитую с master ветку:
`git branch feature <id_commit>` - так как коммиты не сразу удаляются, а остаются в виде недостижимых коммитов

**История переключения веток**

	`git reflog feature` - история коммитов для ветки feature
	`git log --oneling -g` - тот же вывод reflog
	`git reflog --date=iso` - история коммитов c  датами
	
Персоздать удаленную ветку:
	1. Посмотреть исторю коммитев и найти тот, на котором была ветка в последний раз, рядом с коммитом будет HEAD@{число}
	2. `git branch feature HEAD@{число или дата}`

В  reflog запись храниться 90 дней, для удаленных веток - 30 дней
Вместо с коммитами reflogи не отправляются, они работают только локально

`git checkout @{-1}` - вовзврат обратно на ту ветку, откуда мы перешли на master
`git reflog --no-decoreate` - вывести  логи только с сообщениями
`git checkout -` - вовзврат на предыдущую ветку


**Удаление лишний файлов**

Как удалить незакомиченные изменения:
`git checkout -f` - вернет все файлы из рабочей директории в начальное состояние и сбросит индекс
`git checkout -f file_path`- удалит изменения только в данном файле
`git reset --hard` - сделать то же самое
Но эти команды ничего не делают с неотслеживаемыси файлами
`git clean -dxf` - удалит все не остлеживаемые файлы и директории, включая те которые попадают в gitignore


#### Сделать из существующей директории репозиторий
В директории:
`1. git init`
`2. git add <paths>`
`3. git remote add "origin" https://github.com/Amircphys/llm`
`4. git remote set-url "origin" https://github.com/Amircphys/llm`
`5. git push -u origin master`





